<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>gost_reader</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 10px;
      background: #f9f9f9;
      display: flex;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      flex: 1;
    }
    #canvasContainer {
      position: relative;
      display: inline-block;
      border: 1px solid #ccc;
      background: white;
      margin-top: 10px;
    }
    .debug-label {
      position: absolute;
      font-size: 10px;
      pointer-events: none;
      background: rgba(255, 255, 0, 0.7);
      border: 1px solid red;
      padding: 1px 3px;
      white-space: nowrap;
      z-index: 10;
      transform: translateY(-100%);
      display: none;
    }
    .line-label {
      background: rgba(255, 0, 0, 0.7) !important;
      border-color: black !important;
      color: white !important;
      font-weight: bold;
      display: none;
    }
    pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 12px;
      border-radius: 4px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.4;
    }
    .panel {
      background: #fff;
      padding: 12px;
      border-radius: 6px;
      margin: 10px 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      
    }
    .buttons
    {
      width: 100%; height: auto;
      position: relative;
      margin: 5px;
    }
    input[type="text"] {
      width: 90%;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .match-card {
      background: #e8f4fd;
      border-left: 4px solid #007acc;
      padding: 12px;
      margin-top: 10px;
      border-radius: 4px;
    }
    button {
      padding: 8px 16px;
      margin: 0 6px;
      background: #007acc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { opacity: 0.9; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    #detectLinesBtn { background: #8e3dff; }
    #status { 
      color: #d9534f; 
      font-weight: bold;
      margin: 8px 0;
    }

    /* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
    #floorPanel {
      width: 280px;
      background: white;
      border-left: 1px solid #ddd;
      padding: 15px;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    #floorNav {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    #floorNav button {
      padding: 6px 12px;
      background: #3498db;
      font-size: 18px;
    }
    #currentFloor {
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      padding: 8px;
      background: #ecf0f1;
      border-radius: 4px;
    }
    .floor-info {
      background: #f8f9fa;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    .floor-content {
      background: #fff;
      padding: 10px;
      border: 1px solid #eee;
      border-radius: 4px;
      margin-top: 10px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }
    .exact-match {
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .highlight-box {
      position: absolute;
      border: 3px solid #3498db;
      pointer-events: none;
      z-index: 5;
    }
    .pdf-table {
        position: absolute;
  border-collapse: collapse;
  font-family: Arial, sans-serif;
  width: 50%;
  margin: 10px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  border-radius: 15px;
  overflow: hidden;
}

.pdf-table td,
.pdf-table th {
  border: 1px solid #ddd;
  padding: 10px;
  text-align: left;
  vertical-align: top;
}

.pdf-table tr:nth-child(even) {
  background-color: #f9f9f9;
}

h2 
{
  position: relative; padding: 0; margin: 0; color: rgb(134, 93, 247); margin-left: 120px;
}
  </style>
  <style>
    #selectionRect {
  background: rgba(52, 152, 219, 0.1);
}
  </style>
  <style>
    .buttonspannel
    {
      width: 300px;
      height: auto;
    }
    .buttonspannel button 
    {
      margin: 5px;
    }
  </style>
  <style>
    .copy-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #28a745;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .copy-notification.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  </style>
  <style>
    #pdfFile 
    {
      padding: 6px; background-color: white; border: none; outline: 1px solid rgba(0, 0, 0, 0.159); border-radius: 5px;

    }
  </style>
</head>
<body>
  <div class="container">
    <h2>gost reader</h2>
    <p style="padding: 5px;"><a href="index.html" style="color: inherit; text-decoration: none; display: block; height: 40px; width: 40px; position: absolute; top: 0; left: 0; margin: 10px;">‚Ü©Ô∏è </a></p>
    <div class="panel">
      <input type="file" id="pdfFile" accept="application/pdf" />
<div class="buttons">
  <button id="loadBtn">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
  <button id="detectLinesBtn" disabled>–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è</button>
</div>
      <div id="status">–í—ã–±–µ—Ä–∏—Ç–µ PDF...</div>
    </div>

<div class="panel">
  <label>–ü–æ–∏—Å–∫ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é:</label><br>
  <input type="text" id="searchInput" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..." disabled>
  
  <!-- –ù–û–í–û–ï: –≤—ã–±–æ—Ä —ç—Ç–∞–∂–∞-—à–∞–ø–∫–∏ -->
  <div style="margin-top:8px; font-size:13px;">
    <label>–®–∞–ø–∫–∞ —Ç–∞–±–ª–∏—Ü—ã:</label>
    <select id="headerFloorSelect" disabled>
      <option value="-1">–ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å</option>
    </select>
  </div>

  <div class="exact-match">
    <input type="checkbox" id="exactMatch" />
    <label for="exactMatch">–¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ</label>
  </div>
  <div id="searchResult"></div>
</div>

    <!-- <div class="panel">
      <label>–ü–æ–∏—Å–∫ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é:</label><br>
      <input type="text" id="searchInput" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..." disabled>
      <div class="exact-match">
        <input type="checkbox" id="exactMatch" />
        <label for="exactMatch">–¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ</label>
      </div>
      <div id="searchResult"></div>
    </div> -->

    <div class="buttonspannel" style="display: block; padding: 10px; border-radius: 5px; background-color: white; box-shadow: 0 0 5px rgba(0, 0, 0, 0.122);">
      <button id="showHtmlBtn">üëÄ –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä</button>
      <button id="copyHtmlBtn" style="display: none;">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
      <button id="enableSelectMode">–í—ã–¥–µ–ª–∏—Ç—å</button>
      <button id="regionModeBtn" style="display: none;">–†–µ–≥–∏–æ–Ω</button>
      <button id="exportRegionsBtn" style="display: none;">–≠–∫—Å–ø–æ—Ä—Ç —Ä–µ–≥–∏–æ–Ω–æ–≤</button>
      <button id="exportFullHtmlBtn">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
      <!-- <button id="exportTableJsonBtn">üìä –≠–∫—Å–ø–æ—Ä—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ç–∞–±–ª–∏—Ü—ã (JSON)</button> -->
    </div>


<div id="regionsContainer"></div>

<!-- –°–ª–æ–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è HTML-—Ç–∞–±–ª–∏—Ü—ã -->
<div id="htmlOverlay" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:white; z-index:1000; padding:20px; overflow:auto;">
  <button id="closeHtmlOverlay" style="position:fixed; top:5px; left:5px; background:#e74c3c; color:white; border:none; width:30px; height:30px; border-radius:50%; font-weight:bold; cursor:pointer;">√ó</button>
  <div id="renderedHtmlTable"></div>
</div>

    <!-- <button id="createHtmlTableBtn">üìÑ –°–æ–∑–¥–∞—Ç—å HTML-—Ç–∞–±–ª–∏—Ü—É</button> -->
<div class="panel" id="htmlTableOutput" style="display:none;">
  <h3>HTML-—Ç–∞–±–ª–∏—Ü–∞:</h3>
  <pre id="htmlTableCode"></pre>
</div>

    <div id="canvasContainer">
      <canvas id="pdfCanvas"></canvas>
      <div id="selectionRect" style="position:absolute; border:2px dashed #3498db; display:none; pointer-events:none; z-index:100;"></div>
    </div>

    <div class="panel">
      <h3>–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ (–ø–æ –ª–∏–Ω–∏—è–º –∏–ª–∏ –ø–æ Y):</h3>
      <pre id="output"></pre>
    </div>
  </div>

  <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç—Ç–∞–∂–∞–º–∏ -->
  <div id="floorPanel">
    <h3>–ù–∞–≤–∏–≥–∞—Ü–∏—è</h3>
    <div id="floorNav">
      <button id="prevFloor">‚Üê</button>
      <div id="currentFloor">-</div>
      <button id="nextFloor">‚Üí</button>
    </div>
    <div class="floor-info">
      <strong>—Å—Ç—Ä–æ–∫–∏:</strong><br>
      <span id="floorTopLine">-</span><br>
      <span id="floorBottomLine">-</span>
    </div>
    <div class="floor-content" id="floorContent">
      [–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —ç—Ç–∞–∂–∞]
    </div>
  </div>

  <!-- –®–µ—Å—Ç–µ—Ä—ë–Ω–∫–∞ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–∞–Ω–µ–ª–∏ -->
<div id="smartCellToggle" style="
position: fixed; top: 10px; right: 10px; 
width: 32px; height: 32px; 
background: #3498db; color: white; 
border-radius: 50%; 
display: flex; align-items: center; justify-content: center;
cursor: pointer; z-index: 2001;
box-shadow: 0 2px 6px rgba(0,0,0,0.2);
font-size: 18px; z-index: 9999;
">‚öôÔ∏è</div>

<!-- –ü–∞–Ω–µ–ª—å —É–º–Ω–æ–π –∫–ª–µ—Ç–∫–∏ (–∏–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã—Ç–∞) -->
<div id="smartCellPanel" style="
position: fixed; top: 10px; left: 1%;
width: 80%; max-width: 400px;
background: white; padding: 16px; border-radius: 12px; 
box-shadow: 0 4px 20px rgba(0,0,0,0.25); 
z-index: 2000; font-size: 14px;
display: none; /* —Å–∫—Ä—ã—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
">
<label>–£–º–Ω–∞—è –∫–ª–µ—Ç–∫–∞:</label>
<select id="smartCellSelect" style="width: 100%; margin-top: 6px; padding: 6px; font-size: 14px;"></select>

<!-- –ö–Ω–æ–ø–∫–∏ –≤ –¥–≤–∞ —Å—Ç–æ–ª–±—Ü–∞: –õ–µ–≤–æ/–ü—Ä–∞–≤–æ —Å–ª–µ–≤–∞, –í–≤–µ—Ä—Ö/–í–Ω–∏–∑ —Å–ø—Ä–∞–≤–∞ -->
<div style="margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 6px;max-width: 200px;">
  <!-- –õ–µ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü: ‚Üê ‚Üí -->
  <div style="display: flex; flex-direction: column; gap: 6px;">
    <button id="smartUp" style="height: 40px;">‚Üë</button>
    <button id="smartDown" style="height: 40px;">‚Üì</button>
  </div>

  <!-- –ü—Ä–∞–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü: ‚Üë ‚Üì -->
  <div style="display: flex; flex-direction: column; gap: 6px;">
    <button id="smartLeft" style="height: 40px;">‚Üê</button>
    <button id="smartRight" style="height: 40px;">‚Üí</button>
  </div>
</div>

<div id="smartOutput" style="margin-top: 16px; min-height: 50px; background: #f9f9f9; padding: 8px; border-radius: 6px;"></div>
</div>

<script>
// –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–∞–Ω–µ–ª–∏
document.getElementById('smartCellToggle').addEventListener('click', (e) => {
  e.stopPropagation();
  const panel = document.getElementById('smartCellPanel');
  if (panel.style.display === 'block') {
    panel.style.display = 'none';
  } else {
    panel.style.display = 'block';
  }
});

// –°–∫—Ä—ã—Ç—å –ø–∞–Ω–µ–ª—å –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ—ë
document.addEventListener('click', (e) => {
  const panel = document.getElementById('smartCellPanel');
  const toggle = document.getElementById('smartCellToggle');
  if (panel.style.display === 'block' && !panel.contains(e.target) && e.target !== toggle) {
    panel.style.display = 'none';
  }
});
</script>
  <!-- <div id="smartCellPanel" style="
  position: fixed; top: 10px; right: 10px; 
  background: white; padding: 12px; border-radius: 8px; 
  box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 2000;
  font-size: 13px;
">
  <label>–£–º–Ω–∞—è –∫–ª–µ—Ç–∫–∞:</label>
  <select id="smartCellSelect" style="width: 120px; margin-top: 4px;"></select>
  <div style="margin-top: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
    <button id="smartUp" style="grid-column: 2;">‚Üë</button>
    <button id="smartLeft">‚Üê</button>
    <button id="smartRight">‚Üí</button>
    <button id="smartDown" style="grid-column: 2;">‚Üì</button>
  </div>
  <div id="smartOutput" style="margin-top: 12px; min-height: 40px;"></div>
</div> -->

  <script>
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ PDF.js
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    let canvas = null;
    let ctx = null;
    let viewport = null;
    let currentPage = null;
    let currentTextContent = null;
    let structuredRows = [];
    let horizontalLines = [];
    let verticalBreaks = []; // ‚Üê –¥–æ–±–∞–≤—å —ç—Ç—É —Å—Ç—Ä–æ–∫—É
    let currentFloorIndex = -1;
    let currentSmartCellId = null;
    
    function mergeNearbyHorizontalLines(lines) {
  if (lines.length <= 1) return lines;
  
  const merged = [];
  let currentLine = { ...lines[0] };
  
  for (let i = 1; i < lines.length; i++) {
    const nextLine = lines[i];
    
    // –ï—Å–ª–∏ –ª–∏–Ω–∏–∏ –Ω–∞ –æ–¥–Ω–æ–π Y –∏ –±–ª–∏–∑–∫–æ –ø–æ X (–¥–æ–ø—É—Å–∫ 5px)
    if (Math.abs(currentLine.y - nextLine.y) <= 1 && 
        Math.abs(currentLine.endX - nextLine.startX) <= 5) {
      // –û–±—ä–µ–¥–∏–Ω—è–µ–º
      currentLine.endX = nextLine.endX;
    } else {
      // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –ª–∏–Ω–∏—é
      merged.push(currentLine);
      currentLine = { ...nextLine };
    }
  }
  merged.push(currentLine);
  return merged;
}

    // === –§–£–ù–ö–¶–ò–Ø: –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö –ª–∏–Ω–∏–π ===
    function detectHorizontalLines() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const threshold = 128;
      const minLineLength = 50;
      const lines = [];

      for (let y = 0; y < canvas.height; y++) {
        let startX = -1;
        for (let x = 0; x <= canvas.width; x++) {
          if (x < canvas.width) {
            const i = (y * canvas.width + x) * 4;
            const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
            if (brightness <= threshold) {
              if (startX === -1) startX = x;
            } else {
              if (startX !== -1 && (x - startX) >= minLineLength) {
                lines.push({ y, startX, endX: x - 1 });
              }
              startX = -1;
            }
          } else {
            if (startX !== -1 && (x - startX) >= minLineLength) {
              lines.push({ y, startX, endX: x - 1 });
            }
          }
        }
      }
      return lines;
    }

      function detectVerticalLines() {
    if (!ctx || !canvas) return [];
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const threshold = 128;
    const minLineHeight = canvas.height * 0.1; 
    const lines = [];
    for (let x = 0; x < canvas.width; x++) {
      let startY = -1;
      for (let y = 0; y <= canvas.height; y++) {
        if (y < canvas.height) {
          const i = (y * canvas.width + x) * 4;
          const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
          if (brightness <= threshold) {
            if (startY === -1) startY = y;
          } else {
            if (startY !== -1 && (y - startY) >= minLineHeight) {
              lines.push({ x, startY, endY: y - 1 });
            }
            startY = -1;
          }
        } else {
          if (startY !== -1 && (y - startY) >= minLineHeight) {
            lines.push({ x, startY, endY: y - 1 });
          }
        }
      }
    }
    // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã (–ª–∏–Ω–∏–∏ —Ç–æ–ª—â–∏–Ω–æ–π >1px)
    const filteredLines = [];
    let lastX = -100;
    for (const line of lines) {
      if (line.x - lastX > 5) { // –¥–æ–ø—É—Å–∫ 5px
        filteredLines.push(line);
        lastX = line.x;
      }
    }
    return filteredLines;
  }


// === –§–£–ù–ö–¶–ò–Ø: –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –±–ª–æ–∫–æ–≤ –ø–æ "—ç—Ç–∞–∂–∞–º" –º–µ–∂–¥—É –ª–∏–Ω–∏—è–º–∏ ===
   
function groupBlocksIntoRows(blocks) {
      if (horizontalLines.length === 0) {
        const TOLERANCE = 5;
        const rows = [];
        const sortedByY = blocks.sort((a, b) => a.y - b.y);
        for (const block of sortedByY) {
          const existingRow = rows.find(row => Math.abs(row.y - block.y) <= TOLERANCE);
          if (existingRow) {
            existingRow.blocks.push(block);
          } else {
            rows.push({ y: block.y, blocks: [block] });
          }
        }
        rows.forEach(row => row.blocks.sort((a, b) => a.x - b.x));
        return rows;
      }

      const sortedLines = [...horizontalLines].sort((a, b) => a.y - b.y);
      const rows = [];

      blocks.forEach(block => {
        let rowIndex = -1;
        for (let i = 0; i < sortedLines.length - 1; i++) {
          if (block.y > sortedLines[i].y && block.y < sortedLines[i + 1].y) {
            rowIndex = i;
            break;
          }
        }
        if (rowIndex === -1) rowIndex = sortedLines.length - 1;

        if (!rows[rowIndex]) {
          rows[rowIndex] = { 
            y: sortedLines[rowIndex]?.y || block.y, 
            topLine: sortedLines[rowIndex],
            bottomLine: sortedLines[rowIndex + 1],
            blocks: [] 
          };
        }
        rows[rowIndex].blocks.push(block);
      });

      const filteredRows = rows.filter(row => row !== undefined && row.blocks && row.blocks.length > 0);
      filteredRows.forEach(row => row.blocks.sort((a, b) => a.x - b.x));
      return filteredRows;
    }

    // === –§–£–ù–ö–¶–ò–Ø: –ü–æ–∏—Å–∫ —Å—Ç—Ä–æ–∫–∏ –ø–æ –∑–∞–ø—Ä–æ—Å—É ===
    function findRowByQuery(query, exactMatch = false) {
      if (!query.trim()) return null;
      
      return structuredRows.filter(row => {
        return row.blocks.some(block => {
          if (exactMatch) {
            return block.text.toLowerCase() === query.toLowerCase();
          } else {
            return block.text.toLowerCase().includes(query.toLowerCase());
          }
        });
      });
    }

    // === –ó–ê–ì–†–£–ó–ö–ê PDF ===
    document.getElementById('loadBtn').addEventListener('click', async () => {
      const file = document.getElementById('pdfFile').files[0];
      if (!file) return alert('–í—ã–±–µ—Ä–∏—Ç–µ PDF');

      document.getElementById('status').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ PDF...';
      document.getElementById('detectLinesBtn').disabled = true;
      document.getElementById('searchInput').disabled = true;

      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        currentPage = await pdf.getPage(1);

        viewport = currentPage.getViewport({ scale: 2.0 });
        canvas = document.getElementById('pdfCanvas');
        ctx = canvas.getContext('2d');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await currentPage.render({ canvasContext: ctx, viewport }).promise;

        currentTextContent = await currentPage.getTextContent();
        const blocks = currentTextContent.items
          .filter(item => item.str.trim())
          .map(item => {
            const [,, , , x, y] = item.transform;
            const screenPoint = viewport.convertToViewportPoint(x, y);
            return { 
              text: item.str.trim(), 
              x: screenPoint[0], 
              y: screenPoint[1] 
            };
          });

        structuredRows = groupBlocksIntoRows(blocks);
        updateOutputAndLabels();
        updateHeaderFloorSelect(); // ‚úÖ –¥–æ–±–∞–≤–ª–µ–Ω–æ
        document.getElementById('status').textContent = 'PDF –ì–æ—Ç–æ–≤.';
        document.getElementById('detectLinesBtn').disabled = false;
        document.getElementById('searchInput').disabled = false;


        function getSubstageSuffix(headerBlocks, substageLines, columnBounds) {
  if (!substageLines || substageLines.length === 0) return null;

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –±–ª–æ–∫–∏ –ø–æ Y
  const sorted = [...headerBlocks].sort((a, b) => a.y - b.y);
  
  // –ù–∞—Ö–æ–¥–∏–º –æ—Ä–∞–Ω–∂–µ–≤—É—é –ª–∏–Ω–∏—é, –±–ª–∏–∂–∞–π—à—É—é –∫ —Å–µ—Ä–µ–¥–∏–Ω–µ —à–∞–ø–∫–∏
  const midY = (sorted[0].y + sorted[sorted.length - 1].y) / 2;
  const nearestSubstage = substageLines.reduce((prev, curr) => 
    Math.abs(curr.y - midY) < Math.abs(prev.y - midY) ? curr : prev
  );

  // –ë–ª–æ–∫–∏ –ü–û–î –æ—Ä–∞–Ω–∂–µ–≤–æ–π –ª–∏–Ω–∏–µ–π
  const bottomBlocks = sorted.filter(b => b.y > nearestSubstage.y);
  
  // –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–æ–≤–Ω–æ –û–î–ò–ù –±–ª–æ–∫ ‚Äî —ç—Ç–æ —Å—É—Ñ—Ñ–∏–∫—Å –¥–ª—è –≤—Å–µ—Ö
  if (bottomBlocks.length === 1) {
    return bottomBlocks[0].text;
  }

  return null; // –µ—Å–ª–∏ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ ‚Äî –Ω–µ –æ–±—ä–µ–¥–∏–Ω—è–µ–º
}
// === –ö–ù–û–ü–ö–ò –í –ö–ê–†–¢–û–ß–ö–ï –ü–û–ò–°–ö–ê ===
document.getElementById('searchInput').oninput = () => {
  const query = document.getElementById('searchInput').value;
  const exactMatch = document.getElementById('exactMatch').checked;
  const headerIndex = parseInt(document.getElementById('headerFloorSelect').value);
  const resultDiv = document.getElementById('searchResult');

  if (!query) {
    resultDiv.innerHTML = '';
    return;
  }

  const foundRows = findRowByQuery(query, exactMatch);
  if (foundRows.length > 0) {
    resultDiv.innerHTML = '';
    foundRows.forEach((row, idx) => {
      const uniqueId = `card_${Date.now()}_${idx}`;
      let cardHtml = `<div id="${uniqueId}" class="match-card"><strong>–ù–∞–π–¥–µ–Ω–æ (—Å—Ç—Ä–æ–∫–∞ ${structuredRows.indexOf(row)}):</strong><br>`;

      if (headerIndex >= 0 && headerIndex < structuredRows.length && window.columnBounds) {
        const headerRow = structuredRows[headerIndex];
        const columnBounds = window.columnBounds;

        columnBounds.forEach(col => {
          // –ë–µ—Ä—ë–º –í–°–ï –±–ª–æ–∫–∏ –≤ –∫–æ–ª–æ–Ω–∫–µ, –∞ –Ω–µ –æ–¥–∏–Ω
          const headerBlocksInCol = headerRow.blocks
            .filter(b => b.x >= col.left && b.x < col.right)
            .sort((a, b) => a.y - b.y); // —Å–æ—Ä—Ç–∏—Ä—É–µ–º —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑

          if (headerBlocksInCol.length === 0) return;

          // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –≤ –∫–æ–ª–æ–Ω–∫–µ –≤ –æ–¥–∏–Ω –∑–∞–≥–æ–ª–æ–≤–æ–∫
          const headerText = headerBlocksInCol.map(b => b.text).join(' ');

          // –ë–µ—Ä—ë–º –¥–∞–Ω–Ω—ã–µ –≤ —Ç–æ–π –∂–µ –∫–æ–ª–æ–Ω–∫–µ
          const dataInCol = row.blocks
            .filter(b => b.x >= col.left && b.x < col.right)
            .map(b => b.text);
          const dataText = dataInCol.length ? dataInCol.join(', ') : '‚Äî';

          cardHtml += `<div><span style="color:#8e44ad; font-weight:bold;">${headerText}:</span> ${dataText}</div>`;
        });
      } else {
        row.blocks.forEach(block => {
          cardHtml += `<div>${block.text}</div>`;
        });
      }

      cardHtml += `
        <div style="margin-top:10px; display:flex; gap:8px;">
          <button onclick="saveCardAsHtml('${uniqueId}')">üíæ HTML</button>
          <button onclick="saveCardForTelegram('${uniqueId}')">üì± TG</button>
        </div>
      </div>`;
      resultDiv.innerHTML += cardHtml;
    });
  } else {
    resultDiv.innerHTML = '<div style="color:#d9534f">–ù–µ –Ω–∞–π–¥–µ–Ω–æ</div>';
  }
};

      } catch (error) {
        document.getElementById('status').textContent = '–û—à–∏–±–∫–∞: ' + error.message;
        console.error(error);
      }
    });
    // === –û–ë–ù–ê–†–£–ñ–ï–ù–ò–ï –õ–ò–ù–ò–ô ===

    document.getElementById('detectLinesBtn').addEventListener('click', async () => {
  if (!currentPage) return;

  document.getElementById('status').textContent = '–ê–Ω–∞–ª–∏–∑...';
  document.querySelectorAll('.debug-label').forEach(el => el.remove());

  // === 1. –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ ===
  let rawLines = detectHorizontalLines();
  horizontalLines = mergeNearbyHorizontalLines(rawLines);

  // === 2. –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –∏ –∫–æ–ª–æ–Ω–∫–∏ ===
  const verticalLines = detectVerticalLines();
  verticalBreaks = verticalLines.map(line => line.x).sort((a, b) => a - b);

  // –ì—Ä–∞–Ω–∏—Ü—ã –∫–æ–ª–æ–Ω–æ–∫: –¢–û–õ–¨–ö–û –º–µ–∂–¥—É –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–º–∏ –ª–∏–Ω–∏—è–º–∏ (–±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö)
  const columnBounds = [];
  if (verticalBreaks.length < 2) {
    // –ú–µ–Ω–µ–µ 2 –ª–∏–Ω–∏–π ‚Üí –Ω–µ –º–æ–∂–µ–º –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É ‚Üí –æ–¥–Ω–∞ –∫–æ–ª–æ–Ω–∫–∞
    columnBounds.push({ left: 0, right: viewport.width });
  } else {
    // –¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏
    for (let i = 0; i < verticalBreaks.length - 1; i++) {
      columnBounds.push({ left: verticalBreaks[i], right: verticalBreaks[i + 1] });
    }
  }
  window.columnBounds = columnBounds;

  // === 3. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞—á–∞–ª–æ —Ç–∞–±–ª–∏—Ü—ã (–ª–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ –ø–µ—Ä–≤–æ–π –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –∫–æ–ª–æ–Ω–∫–∏) ===
  const tableStartX = columnBounds.length > 0 ? columnBounds[0].left : 0;

  // === 4. –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö –ª–∏–Ω–∏–π ===
  let floorLines = [];
  let substageLines = [];

  if (horizontalLines.length > 0) {
    horizontalLines.forEach(line => {
      // –ó–µ–ª—ë–Ω–∞—è –ª–∏–Ω–∏—è = –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –î–û –∏–ª–∏ –ù–ê –≥—Ä–∞–Ω–∏—Ü–µ —Ç–∞–±–ª–∏—Ü—ã
      if (line.startX <= tableStartX + 5) {
        floorLines.push(line);
      } else {
        substageLines.push(line);
      }
    });
  }

  // // === 5. –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ PDF –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ –ª–∏–Ω–∏–π ===
  // await currentPage.render({ canvasContext: ctx, viewport }).promise;

  // // –ó–µ–ª—ë–Ω—ã–µ (—ç—Ç–∞–∂–∏)
  // ctx.strokeStyle = '#00ff00';
  // ctx.lineWidth = 2;
  // floorLines.forEach(line => {
  //   ctx.beginPath();
  //   ctx.moveTo(line.startX, line.y);
  //   ctx.lineTo(line.endX, line.y);
  //   ctx.stroke();
  //   const label = document.createElement('div');
  //   label.className = 'debug-label line-label';
  //   label.textContent = `Y=${Math.round(line.y)}`;
  //   label.style.left = `${line.startX + 10}px`;
  //   label.style.top = `${line.y}px`;
  //   document.getElementById('canvasContainer').appendChild(label);
  // });

  // // –û—Ä–∞–Ω–∂–µ–≤—ã–µ (—Å—É–±—ç—Ç–∞–ø—ã)
  // ctx.strokeStyle = '#ff9800';
  // ctx.lineWidth = 1;
  // substageLines.forEach(line => {
  //   // –ò—Å–∫–ª—é—á–∞–µ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –∑–µ–ª—ë–Ω—ã—Ö –ª–∏–Ω–∏–π (–ø–æ Y)
  //   const isOverlappingGreen = floorLines.some(green => Math.abs(green.y - line.y) <= 2);
  //   if (isOverlappingGreen) return;

  //   ctx.beginPath();
  //   ctx.moveTo(line.startX, line.y);
  //   ctx.lineTo(line.endX, line.y);
  //   ctx.stroke();
  //   const label = document.createElement('div');
  //   label.className = 'debug-label line-label';
  //   label.textContent = `sub Y=${Math.round(line.y)}`;
  //   label.style.left = `${line.startX + 10}px`;
  //   label.style.top = `${line.y}px`;
  //   label.style.background = 'rgba(255, 152, 0, 0.7)';
  //   label.style.color = 'white';
  //   document.getElementById('canvasContainer').appendChild(label);
  // });

  // // === 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö ===
  // horizontalLines = floorLines; // —Ç–æ–ª—å–∫–æ —ç—Ç–∞–∂–∏ —É—á–∞—Å—Ç–≤—É—é—Ç –≤ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–µ
  // window.substageLines = substageLines.filter(line => 
  //   !floorLines.some(green => Math.abs(green.y - line.y) <= 2)
  // );

  // // === 7. –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã—Ö –ª–∏–Ω–∏–π (–ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–µ –∫—Ä–∞—Å–Ω—ã–µ –ª–∏–Ω–∏–∏) ===
  // verticalLines.forEach(line => {
  //   ctx.strokeStyle = 'red';
  //   ctx.lineWidth = 1;
  //   ctx.beginPath();
  //   ctx.moveTo(line.x, 0);
  //   ctx.lineTo(line.x, canvas.height);
  //   ctx.stroke();

  //   const label = document.createElement('div');
  //   label.className = 'debug-label';
  //   label.textContent = 'break';
  //   label.style.left = `${line.x + 10}px`;
  //   label.style.top = `${canvas.height / 2}px`;
  //   label.style.background = 'red';
  //   label.style.color = 'white';
  //   label.style.fontSize = '10px';
  //   document.getElementById('canvasContainer').appendChild(label);
  // });
    // === 5. –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ PDF –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ –ª–∏–Ω–∏–π (–û–ë–†–ï–ó–ê–ù–ù–´–• –ü–û –ì–†–ê–ù–ò–¶–ê–ú –¢–ê–ë–õ–ò–¶–´) ===
    await currentPage.render({ canvasContext: ctx, viewport }).promise;

// === –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ì–†–ê–ù–ò–¶ –¢–ê–ë–õ–ò–¶–´ ===
let tableTopY = 0;
let tableBottomY = canvas.height;
let tableLeftX = 0;
let tableRightX = canvas.width;

if (floorLines.length > 0) {
  const sortedFloors = [...floorLines].sort((a, b) => a.y - b.y);
  tableTopY = sortedFloors[0].y;
  tableBottomY = sortedFloors[sortedFloors.length - 1].y;
}

if (verticalLines.length > 0) {
  const sortedVerticals = [...verticalLines].sort((a, b) => a.x - b.x);
  tableLeftX = sortedVerticals[0].x;
  tableRightX = sortedVerticals[sortedVerticals.length - 1].x;
}

// === –ó–µ–ª—ë–Ω—ã–µ –ª–∏–Ω–∏–∏ (—ç—Ç–∞–∂–∏) ‚Äî —Ä–∏—Å—É–µ–º –¢–û–õ–¨–ö–û –º–µ–∂–¥—É –∫—Ä–∞–π–Ω–∏–º–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–º–∏ –ª–∏–Ω–∏—è–º–∏ ===
ctx.strokeStyle = '#00ff00';
ctx.lineWidth = 2;
floorLines.forEach(line => {
  const startX = Math.max(line.startX, tableLeftX);
  const endX = Math.min(line.endX, tableRightX);
  if (endX > startX) {
    ctx.beginPath();
    ctx.moveTo(startX, line.y);
    ctx.lineTo(endX, line.y);
    ctx.stroke();
  }

  const label = document.createElement('div');
  label.className = 'debug-label line-label';
  label.textContent = `Y=${Math.round(line.y)}`;
  label.style.left = `${startX + 10}px`;
  label.style.top = `${line.y}px`;
  document.getElementById('canvasContainer').appendChild(label);
});

// === –û—Ä–∞–Ω–∂–µ–≤—ã–µ –ª–∏–Ω–∏–∏ (—Å—É–±—ç—Ç–∞–ø—ã) ‚Äî —Ç–æ–∂–µ –æ–±—Ä–µ–∑–∞–µ–º –ø–æ —à–∏—Ä–∏–Ω–µ —Ç–∞–±–ª–∏—Ü—ã ===
ctx.strokeStyle = '#ff9800';
ctx.lineWidth = 1;
substageLines.forEach(line => {
  const isOverlappingGreen = floorLines.some(green => Math.abs(green.y - line.y) <= 2);
  if (isOverlappingGreen) return;

  const startX = Math.max(line.startX, tableLeftX);
  const endX = Math.min(line.endX, tableRightX);
  if (endX > startX) {
    ctx.beginPath();
    ctx.moveTo(startX, line.y);
    ctx.lineTo(endX, line.y);
    ctx.stroke();
  }

  const label = document.createElement('div');
  label.className = 'debug-label line-label';
  label.textContent = `sub Y=${Math.round(line.y)}`;
  label.style.left = `${startX + 10}px`;
  label.style.top = `${line.y}px`;
  label.style.background = 'rgba(255, 152, 0, 0.7)';
  label.style.color = 'white';
  document.getElementById('canvasContainer').appendChild(label);
});

// === –ö—Ä–∞—Å–Ω—ã–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ ‚Äî —Ä–∏—Å—É–µ–º –¢–û–õ–¨–ö–û –º–µ–∂–¥—É –ø–µ—Ä–≤–æ–π –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–µ–ª—ë–Ω–æ–π –ª–∏–Ω–∏–µ–π ===
verticalLines.forEach(line => {
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 1;
  const topY = tableTopY;
  const bottomY = tableBottomY;
  if (bottomY > topY) {
    ctx.beginPath();
    ctx.moveTo(line.x, topY);
    ctx.lineTo(line.x, bottomY);
    ctx.stroke();
  }

  const label = document.createElement('div');
  label.className = 'debug-label';
  label.textContent = 'break';
  label.style.left = `${line.x + 10}px`;
  label.style.top = `${(topY + bottomY) / 2}px`;
  label.style.background = 'red';
  label.style.color = 'white';
  label.style.fontSize = '10px';
  document.getElementById('canvasContainer').appendChild(label);
});

// === 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö ===
horizontalLines = floorLines;
window.substageLines = substageLines.filter(line => 
  !floorLines.some(green => Math.abs(green.y - line.y) <= 2)
);

  // === 8. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å—Ç—Ä–æ–∫ ===
  const blocks = currentTextContent.items
    .filter(item => item.str.trim())
    .map(item => {
      const [,, , , x, y] = item.transform;
      const screenPoint = viewport.convertToViewportPoint(x, y);
      return { text: item.str.trim(), x: screenPoint[0], y: screenPoint[1] };
    });

  structuredRows = groupBlocksIntoRows(blocks);
  updateOutputAndLabels();
  currentFloorIndex = -1;
  updateFloorPanel();
  updateHeaderFloorSelect();

  // === 9. –ö–∞—Ä—Ç–∞ —è—á–µ–µ–∫ –¥–ª—è "–£–º–Ω–æ–π –∫–ª–µ—Ç–∫–∏" ===
  const cellMap = {};
  structuredRows.forEach((row, rowIndex) => {
    if (window.columnBounds) {
      window.columnBounds.forEach((col, colIndex) => {
        const id = `cell_r${rowIndex}_c${colIndex}`;
        const blocks = row.blocks.filter(b => 
          b.x >= col.left && b.x < col.right
        ).sort((a, b) => a.y - b.y);
        cellMap[id] = {
          id,
          rowIndex,
          colIndex,
          blocks,
          content: blocks.map(b => b.text).join(' | ')
        };
      });
    }
  });
  window.cellMap = cellMap;
  updateSmartCellSelect();

  document.getElementById('status').textContent = `–ù–∞–π–¥–µ–Ω–æ: ${horizontalLines.length} —ç—Ç–∞–∂–µ–π.`;
});

    function detectColumns(blocks) {
  if (blocks.length === 0) return [];

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ X
  const sorted = [...blocks].sort((a, b) => a.x - b.x);

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
  if (verticalBreaks.length > 0) {
  // –î–æ–±–∞–≤–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã: –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  const allBreaks = [0, ...verticalBreaks, viewport.width];
  allBreaks.sort((a, b) => a - b);

  // –£–±–∏—Ä–∞–µ–º –∫—Ä–∞–π–Ω–∏–µ –ø—É—Å—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏ (–µ—Å–ª–∏ –Ω–µ—Ç –±–ª–æ–∫–æ–≤)
  const columns = [];
  for (let i = 0; i < allBreaks.length - 1; i++) {
    const left = allBreaks[i];
    const right = allBreaks[i + 1];

    // –§–∏–ª—å—Ç—Ä—É–µ–º –±–ª–æ–∫–∏ –≤ —ç—Ç–æ–π –∫–æ–ª–æ–Ω–∫–µ
    const colBlocks = sorted.filter(b => b.x >= left && b.x < right);
    if (colBlocks.length > 0) { // —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –±–ª–æ–∫–∏
      columns.push(colBlocks);
    }
  }
  return columns;
}
  // if (verticalBreaks.length > 0) {
  //   const columns = [];
  //   let currentColumn = [sorted[0]];

  //   for (let i = 1; i < sorted.length; i++) {
  //     const x = sorted[i].x;
  //     // –ü—Ä–æ–≤–µ—Ä—è–µ–º: –±–ª–∏–∑–∫–æ –ª–∏ –∫ –∫–∞–∫–æ–π-—Ç–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π –ª–∏–Ω–∏–∏?
  //     const isBreak = verticalBreaks.some(bp => Math.abs(x - bp) < 10); // –¥–æ–ø—É—Å–∫ 10px

  //     if (isBreak) {
  //       columns.push(currentColumn);
  //       currentColumn = [sorted[i]];
  //     } else {
  //       currentColumn.push(sorted[i]);
  //     }
  //   }
  //   columns.push(currentColumn);
  //   return columns;
  // }

  // –ï—Å–ª–∏ –Ω–µ—Ç –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã—Ö –ª–∏–Ω–∏–π ‚Äî –≥—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Ä–∞–∑—Ä—ã–≤–∞–º
  const gaps = [];
  for (let i = 0; i < sorted.length - 1; i++) {
    const gap = sorted[i + 1].x - sorted[i].x;
    gaps.push({ index: i, gap });
  }

  if (gaps.length === 0) {
    return [sorted]; // –æ–¥–Ω–∞ –∫–æ–ª–æ–Ω–∫–∞
  }

  const avgGap = gaps.reduce((sum, g) => sum + g.gap, 0) / gaps.length;
  const COLUMN_THRESHOLD = avgGap * 2;

  const columns = [];
  let currentColumn = [sorted[0]];

  for (let i = 1; i < sorted.length; i++) {
    const gap = sorted[i].x - sorted[i - 1].x;
    if (gap > COLUMN_THRESHOLD) {
      columns.push(currentColumn);
      currentColumn = [sorted[i]];
    } else {
      currentColumn.push(sorted[i]);
    }
  }
  columns.push(currentColumn);
  return columns;
}

    function updateHeaderFloorSelect() {
  const select = document.getElementById('headerFloorSelect');
  select.innerHTML = '<option value="-1">–ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å</option>';
  
  structuredRows.forEach((row, i) => {
    const option = document.createElement('option');
    option.value = i;
    // –ë–µ—Ä—ë–º –ø–µ—Ä–≤—ã–π –±–ª–æ–∫ –∫–∞–∫ –ø—Ä–µ–≤—å—é
    const preview = row.blocks.map(b => b.text).join(' | ').substring(0, 50);
    // const preview = row.blocks.length ? row.blocks[0].text.substring(0, 30) : '–ü—É—Å—Ç–æ';
    option.textContent = `—É—Ä–æ–≤–µ–Ω—å ${i + 1}: ${preview}`;
    select.appendChild(option);
  });
  
  select.disabled = structuredRows.length === 0;
}

    // === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –û–±–Ω–æ–≤–∏—Ç—å –≤—ã–≤–æ–¥ –∏ –º–µ—Ç–∫–∏ ===
    function updateOutputAndLabels() {
      document.getElementById('output').innerHTML = '';
      document.querySelectorAll('.debug-label:not(.line-label)').forEach(el => el.remove());

      structuredRows.forEach((row, rowIndex) => {
        document.getElementById('output').innerHTML += `--- –°—Ç—Ä–æ–∫–∞ ${rowIndex} (Y=${row.y.toFixed(1)}) ---\n`;
        row.blocks.forEach((block, i) => {
          const screenX = block.x;
          const screenY = block.y;

          document.getElementById('output').innerHTML += 
            `  [${i}] X:${block.x.toFixed(1)} | "${block.text}"\n`;

          const label = document.createElement('div');
          label.className = 'debug-label';
          label.textContent = `"${block.text}"`;
          label.style.left = `${screenX}px`;
          label.style.top = `${screenY}px`;
          document.getElementById('canvasContainer').appendChild(label);
        });
      });
    }

    // === –£–ü–†–ê–í–õ–ï–ù–ò–ï –≠–¢–ê–ñ–ê–ú–ò ===
    function updateFloorPanel() {
      const floorCount = structuredRows.length;
      if (floorCount === 0) {
        document.getElementById('currentFloor').textContent = '-';
        document.getElementById('floorTopLine').textContent = '-';
        document.getElementById('floorBottomLine').textContent = '-';
        document.getElementById('floorContent').textContent = '[–ù–µ—Ç —Å—Ç—Ä–æ–∫]';
        return;
      }

      if (currentFloorIndex < 0) currentFloorIndex = 0;
      if (currentFloorIndex >= floorCount) currentFloorIndex = floorCount - 1;

      const currentFloor = structuredRows[currentFloorIndex];
      document.getElementById('currentFloor').textContent = `${currentFloorIndex + 1} –∏–∑ ${floorCount}`;

      const topLine = currentFloor.topLine ? `Y=${Math.round(currentFloor.topLine.y)}` : '–í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞';
      const bottomLine = currentFloor.bottomLine ? `Y=${Math.round(currentFloor.bottomLine.y)}` : '–ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞';
      document.getElementById('floorTopLine').textContent = topLine;
      document.getElementById('floorBottomLine').textContent = bottomLine;

      const content = currentFloor.blocks.map((b, i) => `  [${i}] "${b.text}"`).join('\n');
      document.getElementById('floorContent').textContent = content;

      // –†–∏—Å—É–µ–º —Å–∏–Ω—é—é —Ä–∞–º–∫—É –≤–æ–∫—Ä—É–≥ —ç—Ç–∞–∂–∞
      drawFloorHighlight(currentFloor);
    }

function generateHtmlTable() {
  if (structuredRows.length < 2) {
    return '<p>–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 —Å—Ç—Ä–æ–∫–∏</p>';
  }

  // –ë–µ—Ä—ë–º –í–¢–û–†–û–ô —ç—Ç–∞–∂ (–∏–Ω–¥–µ–∫—Å 1) ‚Äî –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —ç—Ç–æ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–∞–Ω–Ω—ã—Ö
//   const referenceRow = structuredRows[1];
let referenceRow = structuredRows[0];
for (let row of structuredRows) {
  if (row.blocks.length > referenceRow.blocks.length) {
    referenceRow = row;
  }
}
  if (!referenceRow || referenceRow.blocks.length === 0) {
    return '<p>–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤–æ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–µ</p>';
  }

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –±–ª–æ–∫–∏ –ø–æ X
  const sortedBlocks = [...referenceRow.blocks].sort((a, b) => a.x - b.x);

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã —Å—Ç–æ–ª–±—Ü–æ–≤ –ø–æ —Ä–∞–∑—Ä—ã–≤–∞–º > 80px
  const COLUMN_GAP = 80; // –ø–∏–∫—Å–µ–ª–µ–π
  const columns = [];
  let currentStart = sortedBlocks[0].x;

  for (let i = 0; i < sortedBlocks.length; i++) {
    const current = sortedBlocks[i];
    const next = sortedBlocks[i + 1];

    if (!next || (next.x - current.x) > COLUMN_GAP) {
      // –ö–æ–Ω–µ—Ü —Å—Ç–æ–ª–±—Ü–∞
      columns.push({
        minX: currentStart,
        maxX: current.x + (current.text.length * 6), // –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞
        center: (currentStart + current.x) / 2
      });
      if (next) currentStart = next.x;
    }
  }

  if (columns.length === 0) {
    return '<p>–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç–æ–ª–±—Ü—ã</p>';
  }

  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º HTML
//   let html = '<table border="1" cellpadding="12" cellspacing="0" style="border-collapse: collapse; font-family: Arial, sans-serif; width: 80%; margin: 40px auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border-radius: 15px; overflow: hidden;">\n';
//   let html = '<table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse; font-family: Arial, sans-serif; margin: 20px 0;">\n';
    let html = '<table class="pdf-table">\n';

  structuredRows.forEach(row => {
    html += '  <tr>\n';
    
    // –°–æ–∑–¥–∞—ë–º —è—á–µ–π–∫–∏ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Å—Ç–æ–ª–±—Ü–æ–≤
    const cells = Array(columns.length).fill('');

    // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –±–ª–æ–∫–∏ –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º
    row.blocks.forEach(block => {
      // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–π —Å—Ç–æ–ª–±–µ—Ü –ø–æ X
      let bestColIndex = 0;
      let minDist = Math.abs(block.x - columns[0].center);
      
      for (let i = 1; i < columns.length; i++) {
        const dist = Math.abs(block.x - columns[i].center);
        if (dist < minDist) {
          minDist = dist;
          bestColIndex = i;
        }
      }
      
      cells[bestColIndex] = cells[bestColIndex] ? 
        `${cells[bestColIndex]}<br>${block.text}` : 
        block.text;
    });

    cells.forEach(cell => {
  html += `    <td>${cell || ''}</td>\n`;
});

    // cells.forEach(cell => {
    //   html += `    <td>${cell || ''}</td>\n`;
    // });

    html += '  </tr>\n';
  });

  html += '</table>';
  return html;
}

function drawFloorHighlight(floor) {
  // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é —Ä–∞–º–∫—É
  const oldBox = document.querySelector('.highlight-box');
  if (oldBox) oldBox.remove();
  if (!floor) return;

  // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ ‚Äî –∫–∞–∫ —Ä–∞–Ω—å—à–µ
  const topLineY = floor.topLine ? floor.topLine.y : 0;
  const bottomLineY = floor.bottomLine ? floor.bottomLine.y : canvas.height;

  // === –®–ò–†–ò–ù–ê: —Ç–æ–ª—å–∫–æ –º–µ–∂–¥—É –ø–µ—Ä–≤–æ–π –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∫–æ–ª–æ–Ω–∫–æ–π ===
  let leftX = 0;
  let rightX = canvas.width;

  if (window.columnBounds && window.columnBounds.length > 0) {
    // –ë–µ—Ä—ë–º —Å–∞–º—É—é –ª–µ–≤—É—é –∏ —Å–∞–º—É—é –ø—Ä–∞–≤—É—é –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–ª–æ–Ω–æ–∫
    leftX = window.columnBounds[0].left;
    rightX = window.columnBounds[window.columnBounds.length - 1].right;
  }

  const box = document.createElement('div');
  box.className = 'highlight-box';
  box.style.left = `${leftX}px`;
  box.style.top = `${topLineY}px`;
  box.style.width = `${rightX - leftX}px`;
  box.style.height = `${bottomLineY - topLineY}px`;
  box.style.border = '2px solid #3498db'; // —Å–∏–Ω—è—è —Ä–∞–º–∫–∞
  box.style.pointerEvents = 'none';
  box.style.position = 'absolute';
  box.style.zIndex = '2000';
  document.getElementById('canvasContainer').appendChild(box);
}

// function drawFloorHighlight(floor) {
//   // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é —Ä–∞–º–∫—É
//   const oldBox = document.querySelector('.highlight-box');
//   if (oldBox) oldBox.remove();

//   if (!floor) return;

//   // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ª–∏–Ω–∏–π —ç—Ç–∞–∂–∞
//   const topLineY = floor.topLine ? floor.topLine.y : 0;
//   const bottomLineY = floor.bottomLine ? floor.bottomLine.y : canvas.height;

//   // –®–∏—Ä–∏–Ω–∞ ‚Äî –≤—Å—è —à–∏—Ä–∏–Ω–∞ canvas
//   const leftX = 0;
//   const rightX = canvas.width;

//   const box = document.createElement('div');
//   box.className = 'highlight-box';
//   box.style.left = `${leftX}px`;
//   box.style.top = `${topLineY}px`;
//   box.style.width = `${rightX - leftX}px`;
//   box.style.height = `${bottomLineY - topLineY}px`;
//   document.getElementById('canvasContainer').appendChild(box);
// }
    
 
    document.getElementById('prevFloor').addEventListener('click', () => {
      if (structuredRows.length > 0) {
        currentFloorIndex--;
        if (currentFloorIndex < 0) currentFloorIndex = structuredRows.length - 1;
        updateFloorPanel();
      }
    });

    document.getElementById('nextFloor').addEventListener('click', () => {
      if (structuredRows.length > 0) {
        currentFloorIndex++;
        if (currentFloorIndex >= structuredRows.length) currentFloorIndex = 0;
        updateFloorPanel();
      }
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–Ω–µ–ª–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    document.addEventListener('DOMContentLoaded', () => {
      updateFloorPanel();
    });

    // –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å HTML –≤ –±—É—Ñ–µ—Ä
document.getElementById('copyHtmlBtn').addEventListener('click', async () => {
  const html = generateHtmlTable();
  try {
    await navigator.clipboard.writeText(html);
    document.getElementById('status').textContent = 'HTML —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä!';
  } catch (err) {
    document.getElementById('status').textContent = '–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: ' + err.message;
  }
});

// –ü–æ–∫–∞–∑–∞—Ç—å HTML –∫–∞–∫ —Ä–µ–Ω–¥–µ—Ä
document.getElementById('showHtmlBtn').addEventListener('click', () => {
  const html = generateHtmlTable();
  document.getElementById('renderedHtmlTable').innerHTML = html;
  document.getElementById('htmlOverlay').style.display = 'block';
});

// –ó–∞–∫—Ä—ã—Ç—å –æ–≤–µ—Ä–ª–µ–π
document.getElementById('closeHtmlOverlay').addEventListener('click', () => {
  document.getElementById('htmlOverlay').style.display = 'none';
});
  
// let isSelecting = false;
// let startX = 0;
// let startY = 0;
// const selectionRect = document.getElementById('selectionRect');
// const canvasContainer = document.getElementById('canvasContainer');

let isSelecting = false;
let startX = 0;
let startY = 0;
const canvasContainer = document.getElementById('canvasContainer');

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ canvasContainer
function getCoords(e) {
  const rect = canvasContainer.getBoundingClientRect();
  let clientX, clientY;

  if (e.type.startsWith('touch')) {
    const touch = e.touches[0] || e.changedTouches[0];
    clientX = touch.clientX;
    clientY = touch.clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }

  return {
    x: clientX - rect.left,
    y: clientY - rect.top
  };
}

// –ù–∞—á–∞–ª–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è
function startSelection(e) {
  if (!isSelecting || !currentTextContent) return;
  
  e.preventDefault();

  const { x, y } = getCoords(e);
  startX = x;
  startY = y;

  const selectionRect = document.getElementById('selectionRect');
  if (selectionRect) {
    selectionRect.style.display = 'block';
    selectionRect.style.left = startX + 'px';
    selectionRect.style.top = startY + 'px';
    selectionRect.style.width = '0px';
    selectionRect.style.height = '0px';
  }
}

// –î–≤–∏–∂–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–∏
function moveSelection(e) {
  if (!isSelecting) return;
  
  e.preventDefault();

  const { x, y } = getCoords(e);
  const currentX = x;
  const currentY = y;

  const width = currentX - startX;
  const height = currentY - startY;

  const selectionRect = document.getElementById('selectionRect');
  if (selectionRect) {
    selectionRect.style.left = Math.min(startX, currentX) + 'px';
    selectionRect.style.top = Math.min(startY, currentY) + 'px';
    selectionRect.style.width = Math.abs(width) + 'px';
    selectionRect.style.height = Math.abs(height) + 'px';
  }
}

// –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è
async function endSelection(e) {
  if (!isSelecting) return;
  
  e.preventDefault();

  isSelecting = false;
  const selectionRect = document.getElementById('selectionRect');
  if (selectionRect) {
    selectionRect.style.display = 'none';
  }

  const { x: endX, y: endY } = getCoords(e);

  const selLeft = Math.min(startX, endX);
  const selTop = Math.min(startY, endY);
  const selRight = Math.max(startX, endX);
  const selBottom = Math.max(startY, endY);

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –¥–∞–Ω–Ω—ã—Ö
  if (!currentTextContent || !viewport) {
    document.getElementById('status').textContent = '‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö PDF';
    return;
  }

  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –±–ª–æ–∫–∏ —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
  const allBlocks = currentTextContent.items
    .filter(item => item.str.trim())
    .map(item => {
      const [,, , , x, y] = item.transform;
      const pt = viewport.convertToViewportPoint(x, y);
      return { 
        text: item.str.trim(), 
        x: pt[0], 
        y: pt[1] 
      };
    });

  // –ï—Å–ª–∏ –Ω–µ—Ç —Ç–∞–±–ª–∏—Ü—ã ‚Äî –ø—Ä–æ—Å—Ç–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
  if (!horizontalLines || horizontalLines.length === 0 || !window.columnBounds) {
    let html = '';
    allBlocks.forEach(block => {
      if (
        block.x >= selLeft && block.x <= selRight &&
        block.y >= selTop && block.y <= selBottom
      ) {
        const safeText = block.text
          .replace(/&/g, '&amp;')
          .replace(/</g, '<')
          .replace(/>/g, '>');
        html += `<div style="position:absolute; left:${block.x}px; top:${block.y}px; white-space:nowrap; border:1px solid #ccc; padding:2px 4px;">${safeText}</div>`;
      }
    });

    if (html) {
      const fullHtml = `<div style="position:relative; width:${viewport.width}px; height:${viewport.height}px; background:white; font-family:Arial,sans-serif;">${html}</div>`;
      try {
        await navigator.clipboard.writeText(fullHtml);
        // document.getElementById('status').textContent = '‚úÖ –í—ã–¥–µ–ª–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
        const msg = '‚úÖ –í—ã–¥–µ–ª–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
document.getElementById('status').textContent = msg;
showNotification(msg);
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = '‚ùå –û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è';
      }
    } else {
      document.getElementById('status').textContent = '‚ö†Ô∏è –ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–¥–µ–ª–µ–Ω–æ';
    }
    return;
  }

  // –ì—Ä–∞–Ω–∏—Ü—ã —Ç–∞–±–ª–∏—Ü—ã
  const sortedLines = [...horizontalLines].sort((a, b) => a.y - b.y);
  const tableTop = sortedLines[0].y;
  const tableBottom = sortedLines.at(-1).y;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è –ª–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å —Ç–∞–±–ª–∏—Ü–µ–π
  const intersectsTable = !(selBottom < tableTop || selTop > tableBottom);
  if (!intersectsTable) {
    // –í–Ω–µ—Ç–∞–±–ª–∏—á–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
    let html = '';
    allBlocks.forEach(block => {
      if (
        block.x >= selLeft && block.x <= selRight &&
        block.y >= selTop && block.y <= selBottom
      ) {
        const safeText = block.text
          .replace(/&/g, '&amp;')
          .replace(/</g, '<')
          .replace(/>/g, '>');
        html += `<div style="position:absolute; left:${block.x}px; top:${block.y}px; white-space:nowrap; border:1px solid #ccc; padding:2px 4px;">${safeText}</div>`;
      }
    });

    if (html) {
      const fullHtml = `<div style="position:relative; width:${viewport.width}px; height:${viewport.height}px; background:white; font-family:Arial,sans-serif;">${html}</div>`;
      // try {
      //   await navigator.clipboard.writeText(fullHtml);
      //   document.getElementById('status').textContent = '‚úÖ –í–Ω–µ—Ç–∞–±–ª–∏—á–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
      try {
  await navigator.clipboard.writeText(fullHtml);
  const msg = '‚úÖ –í–Ω–µ—Ç–∞–±–ª–∏—á–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
  document.getElementById('status').textContent = msg;
  showNotification(msg);
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = '‚ùå –û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è';
      }
    } else {
      document.getElementById('status').textContent = '‚ö†Ô∏è –ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–¥–µ–ª–µ–Ω–æ';
    }
    return;
  }

  // === –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã ===
  const selectedBlocks = allBlocks.filter(b =>
    b.x >= selLeft && b.x <= selRight &&
    b.y >= selTop && b.y <= selBottom &&
    b.y >= tableTop && b.y <= tableBottom
  );

  if (selectedBlocks.length === 0) {
    document.getElementById('status').textContent = '‚ö†Ô∏è –ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –≤ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏';
    return;
  }

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
  const rowBounds = [];
  for (let i = 0; i < sortedLines.length; i++) {
    const top = i === 0 ? tableTop : sortedLines[i - 1].y;
    const bottom = sortedLines[i].y;
    if (!(bottom < selTop || top > selBottom)) {
      rowBounds.push({ top, bottom, index: i });
    }
  }

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã–µ –∫–æ–ª–æ–Ω–∫–∏
  const colBounds = window.columnBounds.filter(col =>
    !(col.right < selLeft || col.left > selRight)
  ).map(col => ({
    ...col,
    originalIndex: window.columnBounds.indexOf(col)
  }));

  if (rowBounds.length === 0 || colBounds.length === 0) {
    document.getElementById('status').textContent = '‚ö†Ô∏è –í—ã–¥–µ–ª–µ–Ω–∏–µ –Ω–µ –ø–æ–ø–∞–ª–æ –≤ —è—á–µ–π–∫–∏ —Ç–∞–±–ª–∏—Ü—ã';
    return;
  }

  // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –±–ª–æ–∫–∏ –ø–æ —è—á–µ–π–∫–∞–º
  const cells = [];
  rowBounds.forEach(rowBound => {
    colBounds.forEach(colBound => {
      const blocksInCell = selectedBlocks.filter(b =>
        b.x >= colBound.left && b.x < colBound.right &&
        b.y >= rowBound.top && b.y < rowBound.bottom
      ).sort((a, b) => a.y - b.y);

      cells.push({
        rowIndex: rowBound.index,
        colIndex: colBound.originalIndex,
        blocks: blocksInCell
      });
    });
  });

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è HTML
  let html = `<div style="position: relative; width: ${viewport.width}px; height: ${viewport.height}px; background: white; font-family: Arial, sans-serif;">\n`;

  // –í–Ω–µ—Ç–∞–±–ª–∏—á–Ω—ã–µ –±–ª–æ–∫–∏ –≤–Ω—É—Ç—Ä–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è (—Ä–µ–¥–∫–æ, –Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ)
  const outsideBlocks = allBlocks.filter(b =>
    b.x >= selLeft && b.x <= selRight &&
    b.y >= selTop && b.y <= selBottom &&
    (b.y < tableTop || b.y > tableBottom)
  );
  outsideBlocks.forEach(block => {
    const safeText = block.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '<')
      .replace(/>/g, '>');
    html += `  <div style="position: absolute; left: ${block.x}px; top: ${block.y}px; white-space: nowrap; border: 1px solid #ccc; padding: 2px 4px;">${safeText}</div>\n`;
  });

  // –¢–∞–±–ª–∏—Ü–∞
  const tableTopY = rowBounds[0].top;
  html += `  <table style="position: absolute; left: 0; top: ${tableTopY}px; border-collapse: collapse; width: ${viewport.width}px;">\n`;

  const uniqueRowIndices = [...new Set(rowBounds.map(r => r.index))].sort((a, b) => a - b);
  const uniqueColIndices = [...new Set(colBounds.map(c => c.originalIndex))].sort((a, b) => a - b);

  uniqueRowIndices.forEach(rowIndex => {
    html += `    <tr>\n`;
    uniqueColIndices.forEach(colIndex => {
      const cell = cells.find(c => c.rowIndex === rowIndex && c.colIndex === colIndex);
      const content = cell?.blocks.map(b =>
        `<div style="margin: 1px 0; line-height: 1.3;">${b.text.replace(/&/g, '&amp;').replace(/</g, '<').replace(/>/g, '>')}</div>`
      ).join('') || '';

      html += `      <td style="border: 1px solid #ddd; background: rgba(230, 245, 255, 0.4); padding: 6px; vertical-align: top; min-width: 80px;">
        ${content}
      </td>\n`;
    });
    html += `    </tr>\n`;
  });

  html += `  </table>\n</div>`;

  // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    // ... (–≤—Å—ë, —á—Ç–æ –±—ã–ª–æ –¥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è)

  // === –ü–û–ö–ê–ó –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø –ò –ö–û–ü–ò–†–û–í–ê–ù–ò–ï ===
  function showNotification(message) {
    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –µ—Å–ª–∏ –µ—Å—Ç—å
    const old = document.querySelector('.copy-notification');
    if (old) old.remove();

    const notification = document.createElement('div');
    notification.className = 'copy-notification';
    notification.textContent = message;
    document.body.appendChild(notification);

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º
    setTimeout(() => {
      notification.classList.add('show');
    }, 10);

    // –£–±–∏—Ä–∞–µ–º —á–µ—Ä–µ–∑ 2.5 —Å–µ–∫—É–Ω–¥—ã
    setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, 2500);
  }

  try {
    await navigator.clipboard.writeText(html);
    const msg = `‚úÖ –¢–∞–±–ª–∏—Ü–∞ (${uniqueRowIndices.length}√ó${uniqueColIndices.length}) —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!`;
    document.getElementById('status').textContent = msg;
    showNotification(msg);
  } catch (err) {
    console.error(err);
    const fallbackMsg = '‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫ selection-structured.html';
    document.getElementById('status').textContent = fallbackMsg;
    showNotification(fallbackMsg);

    const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'selection-structured.html';
    a.click();
    URL.revokeObjectURL(url);
  }
  // try {
  //   await navigator.clipboard.writeText(html);
  //   document.getElementById('status').textContent = `‚úÖ –¢–∞–±–ª–∏—Ü–∞ (${uniqueRowIndices.length}√ó${uniqueColIndices.length}) —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!`;
  // } catch (err) {
  //   console.error(err);
  //   const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
  //   const url = URL.createObjectURL(blob);
  //   const a = document.createElement('a');
  //   a.href = url;
  //   a.download = 'selection-structured.html';
  //   a.click();
  //   URL.revokeObjectURL(url);
  //   document.getElementById('status').textContent = '‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫ selection-structured.html';
  // }
}

// –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏—è –º—ã—à–∏
canvasContainer.addEventListener('mousedown', startSelection);
canvasContainer.addEventListener('mousemove', moveSelection);
canvasContainer.addEventListener('mouseup', endSelection);

// –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏—è –∫–∞—Å–∞–Ω–∏—è (—Å–º–∞—Ä—Ç—Ñ–æ–Ω—ã)
canvasContainer.addEventListener('touchstart', startSelection, { passive: false });
canvasContainer.addEventListener('touchmove', moveSelection, { passive: false });
canvasContainer.addEventListener('touchend', endSelection, { passive: false });

// –ö–Ω–æ–ø–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞ –≤—ã–¥–µ–ª–µ–Ω–∏—è
document.getElementById('enableSelectMode').addEventListener('click', () => {
  isSelecting = true;
  document.getElementById('status').textContent = '–í—ã–¥–µ–ª–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –Ω–∞ PDF...';
});



let isNewRegionMode = false;
let newRegions = [];
let newStart = null;
let newTempRect = null;

// –ö–Ω–æ–ø–∫–∏
const regionModeBtn = document.getElementById('regionModeBtn');
const exportRegionsBtn = document.getElementById('exportRegionsBtn');
// const canvasContainer = document.getElementById('canvasContainer'); // ‚Üê –æ—Å—Ç–∞–≤–∏—Ç—å –û–î–ù–£

regionModeBtn.addEventListener('click', () => {
  isNewRegionMode = !isNewRegionMode;
  regionModeBtn.textContent = isNewRegionMode 
    ? '‚ùå –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ —Ä–µ–≥–∏–æ–Ω–æ–≤' 
    : 'ü°í –†–µ–∂–∏–º —Ä–µ–≥–∏–æ–Ω–æ–≤ (–Ω–æ–≤—ã–π)';
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º—ã—à–∏ ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω —Ä–µ–∂–∏–º
canvasContainer.addEventListener('mousedown', (e) => {
  if (!isNewRegionMode || !currentTextContent) return;
  e.preventDefault();
  const rect = canvasContainer.getBoundingClientRect();
  newStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };

  newTempRect = document.createElement('div');
  newTempRect.style.cssText = `
    position: absolute;
    border: 2px dashed #8e44ad;
    background: rgba(142, 68, 173, 0.1);
    pointer-events: none;
    z-index: 9999;
  `;
  canvasContainer.appendChild(newTempRect);
});

canvasContainer.addEventListener('mousemove', (e) => {
  if (!isNewRegionMode || !newStart || !newTempRect) return;
  e.preventDefault();
  const rect = canvasContainer.getBoundingClientRect();
  const curX = e.clientX - rect.left;
  const curY = e.clientY - rect.top;

  const x = Math.min(newStart.x, curX);
  const y = Math.min(newStart.y, curY);
  const w = Math.abs(curX - newStart.x);
  const h = Math.abs(curY - newStart.y);

  newTempRect.style.left = x + 'px';
  newTempRect.style.top = y + 'px';
  newTempRect.style.width = w + 'px';
  newTempRect.style.height = h + 'px';
});

canvasContainer.addEventListener('mouseup', (e) => {
  if (!isNewRegionMode || !newTempRect) return;
  e.preventDefault();

  canvasContainer.removeChild(newTempRect);
  newTempRect = null;

  const rect = canvasContainer.getBoundingClientRect();
  const endX = e.clientX - rect.left;
  const endY = e.clientY - rect.top;

  const x = Math.min(newStart.x, endX);
  const y = Math.min(newStart.y, endY);
  const w = Math.abs(endX - newStart.x);
  const h = Math.abs(endY - newStart.y);

  newStart = null;

  if (w < 10 || h < 10) return;

  // –£–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è
  let baseName = "–†–µ–≥–∏–æ–Ω";
  let name = `${baseName} ${newRegions.length + 1}`;
  let idx = 1;
  while (newRegions.some(r => r.name === name)) {
    name = `${baseName} ${newRegions.length + 1}_${idx++}`;
  }

  const regionId = 'new-region-' + Date.now();
  const regionEl = document.createElement('div');
  regionEl.id = regionId;
  regionEl.style.cssText = `
    position: absolute;
    border: 2px solid #8e44ad;
    background: rgba(142, 68, 173, 0.05);
    z-index: 9998;
    cursor: pointer;
  `;
  regionEl.style.left = x + 'px';
  regionEl.style.top = y + 'px';
  regionEl.style.width = w + 'px';
  regionEl.style.height = h + 'px';

  regionEl.addEventListener('dblclick', () => {
    const newName = prompt('–ò–º—è —Ä–µ–≥–∏–æ–Ω–∞:', name);
    if (newName?.trim()) {
      const clean = newName.trim();
      if (newRegions.some(r => r.id !== regionId && r.name === clean)) {
        alert('–ò–º—è —É–∂–µ –∑–∞–Ω—è—Ç–æ!');
        return;
      }
      name = clean;
      const r = newRegions.find(r => r.id === regionId);
      if (r) r.name = name;
    }
  });

  canvasContainer.appendChild(regionEl);
  newRegions.push({ id: regionId, x, y, width: w, height: h, name, el: regionEl });
});

// üî• –≠–ö–°–ü–û–†–¢ –í –ë–£–§–ï–† –û–ë–ú–ï–ù–ê (–ù–ï –í –û–ö–ù–û!)
exportRegionsBtn.addEventListener('click', async () => {
  if (newRegions.length === 0) return alert('–ù–µ—Ç —Ä–µ–≥–∏–æ–Ω–æ–≤!');
  if (!currentTextContent || !viewport) return alert('PDF –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω!');

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–≥–∏–æ–Ω—ã –ø–æ Y (—Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑), —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫
  const sortedRegions = [...newRegions].sort((a, b) => a.y - b.y);

  let fullHtml = `<div style="position: relative; width: ${viewport.width}px; height: ${viewport.height}px; background: white; font-family: Arial, sans-serif;">\n`;

  sortedRegions.forEach((region, index) => {
    const items = [];

    // –°–æ–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –±–ª–æ–∫–∏ –≤ —Ä–µ–≥–∏–æ–Ω–µ
    currentTextContent.items
      .filter(item => item.str.trim())
      .forEach(item => {
        const [,, , , x, y] = item.transform;
        const pt = viewport.convertToViewportPoint(x, y);
        const globalX = pt[0];
        const globalY = pt[1];

        if (
          globalX >= region.x && globalX <= region.x + region.width &&
          globalY >= region.y && globalY <= region.y + region.height
        ) {
          items.push({ text: item.str.trim(), x: globalX, y: globalY });
        }
      });

    if (items.length === 0) return;

    // === –ì–†–£–ü–ü–ò–†–£–ï–ú –ü–û –°–¢–†–û–ö–ê–ú (Y —Å –¥–æ–ø—É—Å–∫–æ–º 5px) ===
    const TOLERANCE = 5;
    const lines = [];
    const sortedByY = items.sort((a, b) => a.y - b.y);

    for (const item of sortedByY) {
      let line = lines.find(l => Math.abs(l.y - item.y) <= TOLERANCE);
      if (!line) {
        line = { y: item.y, words: [] };
        lines.push(line);
      }
      line.words.push({ text: item.text, x: item.x });
    }

    // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ª–æ–≤–∞ –≤ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–µ –ø–æ X
    lines.forEach(line => {
      line.words.sort((a, b) => a.x - b.x);
    });

    // –°–æ–±–∏—Ä–∞–µ–º HTML –¥–ª—è —Å—Ç—Ä–æ–∫–∏
    let blockHtml = '';
    lines.forEach(line => {
      const lineText = line.words.map(w => w.text).join(' ');
      blockHtml += `<div>${lineText}</div>\n`;
    });

    // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
    const blockId = `block_${index + 1}`;

    // –†–∞–º–∫–∞ ‚Äî –∞–±—Å–æ–ª—é—Ç–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è, —Ä–∞–∑–º–µ—Ä ‚Äî –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π
    fullHtml += `<div id="${blockId}" style="
      position: absolute;
      left: ${region.x}px;
      top: ${region.y}px;
      border: 2px solid #e74c3c;
      padding: 8px;
      background: #fff9f9;
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.4;
      box-sizing: border-box;
      min-width: 100px;
      max-width: 600px;
    ">${blockHtml}</div>\n`;
  });

  fullHtml += `</div>`;

  try {
    await navigator.clipboard.writeText(fullHtml);
    document.getElementById('status').textContent = `‚úÖ –†–µ–≥–∏–æ–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã ‚Äî —Ç–æ—á–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ + —É–º–Ω—ã–π —Ç–µ–∫—Å—Ç!`;
  } catch (err) {
    console.error(err);
    alert('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è');
  }
});
  

document.getElementById('exportFullHtmlBtn').addEventListener('click', async () => {
  if (!currentTextContent || !viewport || !window.columnBounds) {
    alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ PDF –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∞–Ω–∞–ª–∏–∑!');
    return;
  }

  // === 1. –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –±–ª–æ–∫–∏ —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ ===
  const allBlocks = currentTextContent.items
    .filter(item => item.str.trim())
    .map(item => {
      const [,, , , x, y] = item.transform;
      const pt = viewport.convertToViewportPoint(x, y);
      return { 
        text: item.str.trim(), 
        x: pt[0], 
        y: pt[1] 
      };
    });

  // === 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∞–±–ª–∏—Ü—ã (–º–µ–∂–¥—É –ø–µ—Ä–≤–æ–π –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–µ–ª—ë–Ω–æ–π –ª–∏–Ω–∏–µ–π) ===
  let tableTop = 0;
  let tableBottom = canvas.height;

  if (horizontalLines.length > 0) {
    const sortedLines = [...horizontalLines].sort((a, b) => a.y - b.y);
    tableTop = sortedLines[0].y;          // –ø–µ—Ä–≤–∞—è –∑–µ–ª—ë–Ω–∞—è –ª–∏–Ω–∏—è ‚Äî –≤–µ—Ä—Ö —Ç–∞–±–ª–∏—Ü—ã
    tableBottom = sortedLines.at(-1).y;   // –ø–æ—Å–ª–µ–¥–Ω—è—è –∑–µ–ª—ë–Ω–∞—è –ª–∏–Ω–∏—è ‚Äî –Ω–∏–∑ —Ç–∞–±–ª–∏—Ü—ã
  }

  // === 3. –†–∞–∑–¥–µ–ª—è–µ–º –±–ª–æ–∫–∏ ===
  const outsideBlocks = allBlocks.filter(b => b.y < tableTop || b.y > tableBottom);
  const insideBlocks = allBlocks.filter(b => b.y >= tableTop && b.y <= tableBottom);

  // === 4. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º HTML ===
  let html = `<div style="position: relative; width: ${viewport.width}px; height: ${viewport.height}px; background: white; font-family: Arial, sans-serif;">\n`;

  // --- –í–ù–ï–¢–ê–ë–õ–ò–ß–ù–´–ï –ë–õ–û–ö–ò: –∫–∞–∫ –≤ —Å—ã—Ä–æ–º –∫–ª–æ–Ω–µ ---
  outsideBlocks.forEach(block => {
    const safeText = block.text
      .replace(/&/g, '&amp;')
      .replace(/</g, '<')
      .replace(/>/g, '>');
    html += `  <div style="position: absolute; left: ${block.x}px; top: ${block.y}px; white-space: nowrap; border: 1px solid #ccc; padding: 2px 4px;">${safeText}</div>\n`;
  });

  // --- –í–ù–£–¢–†–ò–¢–ê–ë–õ–ò–ß–ù–´–ï –ë–õ–û–ö–ò: —Å—Ç—Ä–æ–∏–º —Ç–∞–±–ª–∏—Ü—É ---
  if (insideBlocks.length > 0 && horizontalLines.length > 0) {
    // –ì—Ä–∞–Ω–∏—Ü—ã —Å—Ç—Ä–æ–∫
    const sortedLines = [...horizontalLines].sort((a, b) => a.y - b.y);
    const rowBounds = [];
    for (let i = 0; i < sortedLines.length; i++) {
      const top = i === 0 ? tableTop : sortedLines[i - 1].y;
      const bottom = sortedLines[i].y;
      rowBounds.push({ top, bottom });
    }

    // –°–æ–∑–¥–∞—ë–º —è—á–µ–π–∫–∏ –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –±–ª–æ–∫–∏
    const cells = [];
    rowBounds.forEach((rowBound, rowIndex) => {
      window.columnBounds.forEach((colBound, colIndex) => {
        const blocksInCell = insideBlocks.filter(b =>
          b.x >= colBound.left && b.x < colBound.right &&
          b.y >= rowBound.top && b.y < rowBound.bottom
        ).sort((a, b) => a.y - b.y);

        cells.push({
          id: `cell_r${rowIndex}_c${colIndex}`,
          floorIndex: rowIndex,
          colIndex: colIndex,
          left: colBound.left,
          top: rowBound.top,
          blocks: blocksInCell
        });
      });
    });

    // –†–∏—Å—É–µ–º —Ç–∞–±–ª–∏—Ü—É
    html += `  <table style="position: absolute; left: 0; top: ${tableTop}px; border-collapse: collapse; width: ${viewport.width}px;">\n`;
    rowBounds.forEach((_, rowIndex) => {
      html += `    <tr>\n`;
      window.columnBounds.forEach((_, colIndex) => {
        const cell = cells.find(c => c.floorIndex === rowIndex && c.colIndex === colIndex);
        const content = cell.blocks.map(b => 
          `<div style="margin: 1px 0; line-height: 1.3;">${b.text.replace(/&/g, '&amp;').replace(/</g, '<').replace(/>/g, '>')}</div>`
        ).join('');
        html += `      <td id="${cell.id}" data-floor="${rowIndex}" data-col="${colIndex}" 
        style="border: 1px solid #ddd; background: rgba(230, 245, 255, 0.4); padding: 6px; vertical-align: top; min-width: 80px;">
          ${content}
        </td>\n`;
      });
      html += `    </tr>\n`;
    });
    html += `  </table>\n`;
  }

  html += `</div>`;

// === –ü–†–ï–í–¨–Æ –°–¢–†–£–ö–¢–£–†–´ –¢–ê–ë–õ–ò–¶–´ (—è—á–µ–π–∫–∏) ===
if (window.columnBounds && horizontalLines.length > 0) {
  const sortedLines = [...horizontalLines].sort((a, b) => a.y - b.y);
  const rowCount = sortedLines.length;
  const colCount = window.columnBounds.length;
  const totalCells = rowCount * colCount;

  // –°–æ–∑–¥–∞—ë–º –æ–≤–µ—Ä–ª–µ–π
  const previewOverlay = document.createElement('div');
  previewOverlay.style.cssText = `
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    color: white;
    font-family: monospace;
    pointer-events: none;
  `;
  previewOverlay.innerHTML = `<div style="margin-bottom: 20px; font-size: 20px;">–Ø—á–µ–µ–∫: ${totalCells} (${rowCount} √ó ${colCount})</div>`;

  // –ú–∏–Ω–∏-—Ç–∞–±–ª–∏—Ü–∞
  const miniTable = document.createElement('div');
  miniTable.style.cssText = `
    display: grid;
    grid-template-rows: repeat(${rowCount}, 12px);
    grid-template-columns: repeat(${colCount}, 12px);
    gap: 2px;
    width: fit-content;
  `;
  for (let i = 0; i < totalCells; i++) {
    const cell = document.createElement('div');
    cell.style.cssText = `
      width: 12px;
      height: 12px;
      background: #3498db;
      border-radius: 2px;
    `;
    miniTable.appendChild(cell);
  }
  previewOverlay.appendChild(miniTable);
  document.body.appendChild(previewOverlay);

  // –£–±—Ä–∞—Ç—å —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
  setTimeout(() => {
    if (previewOverlay.parentNode) {
      previewOverlay.parentNode.removeChild(previewOverlay);
    }
  }, 3000);
}

  // === 5. –ö–æ–ø–∏—Ä—É–µ–º –≤ –±—É—Ñ–µ—Ä ===
  try {
    await navigator.clipboard.writeText(html);
    document.getElementById('status').textContent = '‚úÖ –ì–∏–±—Ä–∏–¥–Ω—ã–π –∫–ª–æ–Ω —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!';
  } catch (err) {
    const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'structured-clone.html';
    a.click();
    URL.revokeObjectURL(url);
    document.getElementById('status').textContent = '‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫ structured-clone.html';
  }
}); 

// === –°–û–•–†–ê–ù–ï–ù–ò–ï –ö–ê–†–¢–û–ß–ö–ò –ö–ê–ö HTML (–∫–∞–∫ –≤ —Ç–≤–æ—ë–º —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–µ) ===
window.saveCardAsHtml = async function(cardId) {
  const card = document.querySelector(`#${cardId}`).closest('.match-card');
  if (!card) return;

  // –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–µ <div>
  const lines = Array.from(card.querySelectorAll('div')).filter(line => {
    return !line.querySelector('button') && !line.querySelector('strong');
  });

  // –ë–µ—Ä—ë–º innerHTML –∫–∞–∂–¥–æ–≥–æ –±–ª–æ–∫–∞ ‚Äî –æ–Ω —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–≤–æ—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
  const content = lines.map(line => line.innerHTML).join('<br>'); // –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ .join('')

  // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ —Å—Ç–∏–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –±–ª–æ–∫
  const html = `
    <div style="background: #eaf7ff; border-left: 4px solid #3498db; padding: 16px; margin: 10px; font-family: Arial, sans-serif; line-height: 1.6;">
      ${content}
    </div>
  `.trim();

  try {
    await navigator.clipboard.writeText(html);
    document.getElementById('status').textContent = '‚úÖ –ö–∞—Ä—Ç–æ—á–∫–∞ –≤ HTML!';
  } catch (err) {
    // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ —Ñ–∞–π–ª
    const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'card.html';
    a.click();
    URL.revokeObjectURL(url);
    document.getElementById('status').textContent = '‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫ card.html';
  }
};

window.saveCardForTelegram = async function(cardId) {
  const card = document.querySelector(`#${cardId}`).closest('.match-card');
  if (!card) return;

  let text = '';
  const labels = card.querySelectorAll('span[style*="color:#8e44ad"]');
  labels.forEach(label => {
    const key = label.textContent.trim();
    const value = label.nextSibling?.textContent?.trim() || '‚Äî';
    text += `${key}: ${value}\n`;
  });

  if (!text) {
    const lines = card.querySelectorAll('div');
    lines.forEach(line => {
      if (!line.querySelector('button') && !line.querySelector('strong')) {
        const content = line.textContent.trim();
        if (content) text += content + '\n';
      }
    });
  }

  // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –í–ï–°–¨ —Ç–µ–∫—Å—Ç –≤ —Å–ø–æ–π–ª–µ—Ä Telegram
  const spoilerText = `||${text.trim()}||`;

  try {
    await navigator.clipboard.writeText(spoilerText);
    document.getElementById('status').textContent = '‚úÖ –î–ª—è Telegram!';
  } catch (err) {
    alert('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è');
  }
};

function updateSmartCellSelect() {
  const select = document.getElementById('smartCellSelect');
  select.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–µ—Ç–∫—É</option>';
  if (window.cellMap) {
    Object.keys(window.cellMap).forEach(id => {
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = id;
      select.appendChild(opt);
    });
    if (currentSmartCellId && window.cellMap[currentSmartCellId]) {
      select.value = currentSmartCellId;
    }
  }
}

function highlightCell(cellId) {
  const canvasContainer = document.getElementById('canvasContainer');
  document.querySelectorAll('.smart-cell-highlight').forEach(el => el.remove());

  if (!window.cellMap || !window.cellMap[cellId]) return;

  const cell = window.cellMap[cellId];
  if (cell.rowIndex >= structuredRows.length || !window.columnBounds[cell.colIndex]) return;

  const row = structuredRows[cell.rowIndex];
  const col = window.columnBounds[cell.colIndex];
  const topY = row.topLine ? row.topLine.y : 0;
  const bottomY = row.bottomLine ? row.bottomLine.y : canvas.height;

  const box = document.createElement('div');
  box.className = 'smart-cell-highlight';
  box.style.cssText = `
    position: absolute;
    left: ${col.left}px;
    top: ${topY}px;
    width: ${col.right - col.left}px;
    height: ${bottomY - topY}px;
    border: 3px solid #00ffff; /* –±–∏—Ä—é–∑–∞ */
    pointer-events: none;
    z-index: 2001;
  `;
  canvasContainer.appendChild(box);
}

// === –§–£–ù–ö–¶–ò–Ø: –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏–π –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏ ===
function detectOrangeLinesInCell(cellId) {
    if (!window.cellMap || !window.cellMap[cellId] || !window.substageLines) {
        return [];
    }

    const cell = window.cellMap[cellId];
    const row = structuredRows[cell.rowIndex];
    const col = window.columnBounds[cell.colIndex];

    const topY = row.topLine ? row.topLine.y : 0;
    const bottomY = row.bottomLine ? row.bottomLine.y : canvas.height;

    // –§–∏–ª—å—Ç—Ä—É–µ–º –æ—Ä–∞–Ω–∂–µ–≤—ã–µ –ª–∏–Ω–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏
    const orangeLinesInCell = window.substageLines.filter(line => {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ª–∏–Ω–∏—è –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ Y –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏
        const isInsideY = line.y > topY && line.y < bottomY;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ª–∏–Ω–∏—è –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –∫–æ–ª–æ–Ω–∫—É –ø–æ X (—Ö–æ—Ç—è –±—ã —á–∞—Å—Ç–∏—á–Ω–æ)
        const intersectsX = line.endX > col.left && line.startX < col.right;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ª–∏–Ω–∏—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª–∏–Ω–Ω–∞—è –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏
        const lineStartInCell = Math.max(line.startX, col.left);
        const lineEndInCell = Math.min(line.endX, col.right);
        const lineLengthInCell = lineEndInCell - lineStartInCell;
        const isLongEnough = lineLengthInCell > 20; // –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ 20px
        
        return isInsideY && intersectsX && isLongEnough;
    });

    return orangeLinesInCell;
}

// === –§–£–ù–ö–¶–ò–Ø: –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –æ—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏–π ===
function highlightOrangeLinesInCell(cellId) {
    const canvasContainer = document.getElementById('canvasContainer');
    
    // –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    document.querySelectorAll('.orange-line-detector').forEach(el => el.remove());

    const orangeLines = detectOrangeLinesInCell(cellId);
    
    if (orangeLines.length === 0) {
        return false; // –ª–∏–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–∞—Å–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –¥–ª—è –∫–∞–∂–¥–æ–π –Ω–∞–π–¥–µ–Ω–Ω–æ–π –ª–∏–Ω–∏–∏
    orangeLines.forEach((line, index) => {
        const cell = window.cellMap[cellId];
        const col = window.columnBounds[cell.colIndex];
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∏–¥–∏–º—É—é —á–∞—Å—Ç—å –ª–∏–Ω–∏–∏ –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏
        const visibleStartX = Math.max(line.startX, col.left);
        const visibleEndX = Math.min(line.endX, col.right);

        // –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ª–∏–Ω–∏–∏
        const lineIndicator = document.createElement('div');
        lineIndicator.className = 'orange-line-detector';
        lineIndicator.style.cssText = `
            position: absolute;
            left: ${visibleStartX}px;
            top: ${line.y - 1}px;
            width: ${visibleEndX - visibleStartX}px;
            height: 2px;
            background: #ff0000;
            pointer-events: none;
            z-index: 2003;
        `;
        canvasContainer.appendChild(lineIndicator);

        // –î–æ–±–∞–≤–ª—è–µ–º –±–µ–π–¥–∂-—Å—á—ë—Ç—á–∏–∫
        if (index === 0) {
            const badge = document.createElement('div');
            badge.className = 'orange-line-detector';
            badge.style.cssText = `
                position: absolute;
                left: ${visibleStartX + 10}px;
                top: ${line.y - 20}px;
                background: #ff0000;
                color: white;
                padding: 2px 6px;
                border-radius: 10px;
                font-size: 10px;
                font-weight: bold;
                pointer-events: none;
                z-index: 2004;
            `;
            badge.textContent = `–õ–∏–Ω–∏–π: ${orangeLines.length}`;
            canvasContainer.appendChild(badge);
        }
    });

    return orangeLines.length > 0;
}

// === –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —è—á–µ–π–∫–µ ===
function showCellInfo(cellId, direction = 'self') {
    const output = document.getElementById('smartOutput');
    document.querySelectorAll('.smart-cell-highlight, .subcell-highlight, .orange-line-detector').forEach(el => el.remove());

    if (!window.cellMap || !window.cellMap[cellId]) {
        output.innerHTML = '<div style="color:#d9534f;">–ö–ª–µ—Ç–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</div>';
        return;
    }

    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–π —è—á–µ–π–∫–∏
    highlightCell(cellId);
    
    // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∞ –æ—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏–π
    const hasOrangeLines = highlightOrangeLinesInCell(cellId);
    
    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å—É–±—ä—è—á–µ–µ–∫ + –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
    const subcellCount = highlightSubcells(cellId);

    const cell = window.cellMap[cellId];
    
    let html = `<div><strong>–ê–∫—Ç–∏–≤–Ω–∞—è:</strong> ${cell.id} ‚Üí ${cell.content || '‚Äî'}</div>`;
    html += `<div style="margin-top:6px; color:#f57f17; font-weight:bold;">–°—É–±—ä—è—á–µ–µ–∫: ${subcellCount}</div>`;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏—è—Ö
    if (hasOrangeLines) {
        html += `<div style="margin-top:4px; color:#ff0000; font-weight:bold;">üîç –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—Ä–∞–Ω–∂–µ–≤—ã–µ –ª–∏–Ω–∏–∏!</div>`;
    } else {
        html += `<div style="margin-top:4px; color:#666;">–û—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏–π –Ω–µ—Ç</div>`;
    }

    output.innerHTML = html;
}

// === –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å—É–±—ä—è—á–µ–µ–∫ ===
function highlightSubcells(cellId) {
    const canvasContainer = document.getElementById('canvasContainer');
    document.querySelectorAll('.subcell-highlight').forEach(el => el.remove());

    if (!window.cellMap || !window.cellMap[cellId]) return 0;

    const cell = window.cellMap[cellId];
    const row = structuredRows[cell.rowIndex];
    const col = window.columnBounds[cell.colIndex];

    const topY = row.topLine ? row.topLine.y : 0;
    const bottomY = row.bottomLine ? row.bottomLine.y : canvas.height;

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ –æ—Ä–∞–Ω–∂–µ–≤—ã–µ –ª–∏–Ω–∏–∏ –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
    const orangeLines = detectOrangeLinesInCell(cellId);
    const uniqueLines = orangeLines
        .map(line => line.y)
        .filter((y, index, array) => array.indexOf(y) === index) // —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ Y
        .sort((a, b) => a - b);

    // –ì—Ä–∞–Ω–∏—Ü—ã —Å–µ–≥–º–µ–Ω—Ç–æ–≤: –æ—Ç –≤–µ—Ä—Ö–∞ —è—á–µ–π–∫–∏ ‚Üí –æ—Ä–∞–Ω–∂–µ–≤—ã–µ –ª–∏–Ω–∏–∏ ‚Üí –¥–æ –Ω–∏–∑–∞
    const segmentBounds = [topY, ...uniqueLines, bottomY];

    // –°—á–∏—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ —Å–µ–≥–º–µ–Ω—Ç—ã, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –µ—Å—Ç—å —Ç–µ–∫—Å—Ç
    let validSegments = 0;
    const highlightedSegments = [];

    for (let i = 0; i < segmentBounds.length - 1; i++) {
        const segTop = segmentBounds[i];
        const segBottom = segmentBounds[i + 1];
        if (segBottom - segTop < 3) continue;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –±–ª–æ–∫–∏ –≤ —ç—Ç–æ–º —Å–µ–≥–º–µ–Ω—Ç–µ
        const blocksInSegment = cell.blocks.filter(block =>
            block.y >= segTop && block.y < segBottom
        );

        if (blocksInSegment.length > 0) {
            validSegments++;
            highlightedSegments.push({ top: segTop, bottom: segBottom });
        }
    }

    // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–µ–≥–º–µ–Ω—Ç—ã —Å —Ç–µ–∫—Å—Ç–æ–º
    highlightedSegments.forEach(seg => {
        const segBox = document.createElement('div');
        segBox.className = 'subcell-highlight';
        segBox.style.cssText = `
            position: absolute;
            left: ${col.left}px;
            top: ${seg.top}px;
            width: ${col.right - col.left}px;
            height: ${seg.bottom - seg.top}px;
            border: 2px solid #ffeb3b;
            background: rgba(255, 235, 59, 0.1);
            pointer-events: none;
            z-index: 2002;
        `;
        canvasContainer.appendChild(segBox);
    });

    return validSegments;
}


document.getElementById('smartCellSelect').addEventListener('change', (e) => {
  const id = e.target.value;
  if (id) {
    currentSmartCellId = id;
    showCellInfo(id); // ‚Üê –≤–º–µ—Å—Ç–æ highlightCell + —Ä—É—á–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞
  } else {
    currentSmartCellId = null;
    document.querySelectorAll('.smart-cell-highlight, .subcell-highlight').forEach(el => el.remove());
    document.getElementById('smartOutput').innerHTML = '';
  }
});



// === –§–£–ù–ö–¶–ò–Ø: –ü–æ–∏—Å–∫ —è—á–µ–µ–∫, –∫–∞—Å–∞—é—â–∏—Ö—Å—è –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è —Ç–µ–∫—É—â–µ–π ===
function findRightTouchingCells(cellId) {
    if (!window.cellMap || !window.cellMap[cellId]) return [];
    
    const currentCell = window.cellMap[cellId];
    const currentCol = window.columnBounds[currentCell.colIndex];
    const currentRow = structuredRows[currentCell.rowIndex];
    
    const currentTop = currentRow.topLine ? currentRow.topLine.y : 0;
    const currentBottom = currentRow.bottomLine ? currentRow.bottomLine.y : canvas.height;
    const currentRight = currentCol.right;
    
    const touchingCells = [];
    
    // –ò—â–µ–º –≤—Å–µ —è—á–µ–π–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –∫–∞—Å–∞—é—Ç—Å—è –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è —Ç–µ–∫—É—â–µ–π
    Object.values(window.cellMap).forEach(cell => {
        if (cell.id === cellId) return; // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ç–µ–∫—É—â—É—é
        
        const cellCol = window.columnBounds[cell.colIndex];
        const cellRow = structuredRows[cell.rowIndex];
        
        const cellLeft = cellCol.left;
        const cellTop = cellRow.topLine ? cellRow.topLine.y : 0;
        const cellBottom = cellRow.bottomLine ? cellRow.bottomLine.y : canvas.height;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Å–∞–Ω–∏–µ –ø–æ X (–ø—Ä–∞–≤—ã–π –∫—Ä–∞–π —Ç–µ–∫—É—â–µ–π = –ª–µ–≤—ã–π –∫—Ä–∞–π —Å–æ—Å–µ–¥–Ω–µ–π)
        const isTouchingX = Math.abs(currentRight - cellLeft) <= 2; // –¥–æ–ø—É—Å–∫ 2px
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –ø–æ Y (—Ö–æ—Ç—è –±—ã —á–∞—Å—Ç–∏—á–Ω–æ–µ)
        const isOverlappingY = !(cellBottom <= currentTop || cellTop >= currentBottom);
        
        if (isTouchingX && isOverlappingY) {
            touchingCells.push(cell);
        }
    });
    
    return touchingCells;
}

// === –§–£–ù–ö–¶–ò–Ø: –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –ø—Ä–æ—Å—Ç—Ä–µ–ª –ø–æ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é ===
function shootRightRecursive(cellId, visited = new Set(), depth = 0) {
    if (visited.has(cellId)) return null;
    visited.add(cellId);
    
    const cell = window.cellMap[cellId];
    if (!cell) return null;
    
    const result = {
        id: cellId,
        content: cell.content,
        rowIndex: cell.rowIndex,
        colIndex: cell.colIndex,
        depth: depth,
        children: []
    };
    
    // –ù–∞—Ö–æ–¥–∏–º —è—á–µ–π–∫–∏, –∫–∞—Å–∞—é—â–∏–µ—Å—è –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è
    const rightCells = findRightTouchingCells(cellId);
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é —Å–æ—Å–µ–¥–Ω—é—é —è—á–µ–π–∫—É
    rightCells.forEach(nextCell => {
        if (!visited.has(nextCell.id)) {
            const childResult = shootRightRecursive(nextCell.id, visited, depth + 1);
            if (childResult) {
                result.children.push(childResult);
            }
        }
    });
    
    return result;
}

// === –§–£–ù–ö–¶–ò–Ø: –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—É—Ç–∏ –ø—Ä–æ—Å—Ç—Ä–µ–ª–∞ ===
function visualizeShootPath(tree) {
    const canvasContainer = document.getElementById('canvasContainer');
    
    // –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
    document.querySelectorAll('.shoot-path, .shoot-node').forEach(el => el.remove());
    
    if (!tree) return;
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
    function visualizeNode(node, parentX = null, parentY = null) {
        const cell = window.cellMap[node.id];
        const col = window.columnBounds[cell.colIndex];
        const row = structuredRows[cell.rowIndex];
        
        const centerX = col.left + (col.right - col.left) / 2;
        const centerY = row.topLine ? row.topLine.y + 20 : 20;
        
        // –†–∏—Å—É–µ–º —É–∑–µ–ª
        const nodeEl = document.createElement('div');
        nodeEl.className = 'shoot-node';
        nodeEl.style.cssText = `
            position: absolute;
            left: ${centerX - 40}px;
            top: ${centerY}px;
            width: 80px;
            padding: 4px;
            background: ${node.depth === 0 ? '#3498db' : '#e74c3c'};
            color: white;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            pointer-events: none;
            z-index: 2005;
            cursor: pointer;
        `;
        nodeEl.textContent = `R${node.rowIndex}C${node.colIndex}`;
        nodeEl.title = node.content;
        canvasContainer.appendChild(nodeEl);
        
        // –†–∏—Å—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Ä–æ–¥–∏—Ç–µ–ª–µ–º
        if (parentX !== null && parentY !== null) {
            const pathEl = document.createElement('div');
            pathEl.className = 'shoot-path';
            pathEl.style.cssText = `
                position: absolute;
                left: ${parentX}px;
                top: ${parentY + 20}px;
                width: ${centerX - parentX}px;
                height: 2px;
                background: #27ae60;
                pointer-events: none;
                z-index: 2004;
                transform-origin: left center;
            `;
            canvasContainer.appendChild(pathEl);
        }
        
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–µ—Ç–µ–π
        node.children.forEach(child => {
            visualizeNode(child, centerX, centerY);
        });
    }
    
    visualizeNode(tree);
}

// === –§–£–ù–ö–¶–ò–Ø: –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ –ø—Ä–æ—Å—Ç—Ä–µ–ª–∞ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ ===
function displayShootTree(tree) {
    const output = document.getElementById('smartOutput');
    
    if (!tree) {
        output.innerHTML = '<div style="color:#666;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ—Å—Ç—Ä–µ–ª–∞</div>';
        return;
    }
    
    let html = `<div style="margin-bottom: 10px; font-weight: bold; color: #2c3e50;"> —Å—Ç—Ä–æ–∫–∞:</div>`;
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è HTML
    function buildTreeHtml(node, level = 0) {
        const indent = '&nbsp;'.repeat(level * 4);
        const hasChildren = node.children.length > 0;
        
        let nodeHtml = `
            <div style="margin: 4px 0; padding: 6px; background: ${level === 0 ? '#e3f2fd' : '#fff3e0'}; 
                        border: 1px solid ${level === 0 ? '#bbdefb' : '#ffcc80'}; border-radius: 4px; 
                        cursor: pointer;" 
                 onclick="selectShootNode('${node.id}')"
                 onmouseover="highlightShootNode('${node.id}')"
                 onmouseout="clearShootHighlight()">
                ${indent}${hasChildren ? 'üîΩ' : 'üîπ'} 
                <strong>R${node.rowIndex}C${node.colIndex}:</strong> 
                ${node.content || '‚Äî'}
                ${hasChildren ? ` (+${node.children.length})` : ''}
            </div>
        `;
        
        node.children.forEach(child => {
            nodeHtml += buildTreeHtml(child, level + 1);
        });
        
        return nodeHtml;
    }
    
    html += buildTreeHtml(tree);
    output.innerHTML = html;
}

// === –§–£–ù–ö–¶–ò–ò –î–õ–Ø –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–Ø –° –î–ï–†–ï–í–û–ú ===
function selectShootNode(cellId) {
    currentSmartCellId = cellId;
    document.getElementById('smartCellSelect').value = cellId;
    showCellInfo(cellId);
    
    // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º –¥–µ—Ä–µ–≤–æ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —É–∑–ª–∞
    const newTree = shootRightRecursive(cellId);
    displayShootTree(newTree);
}

function highlightShootNode(cellId) {
    document.querySelectorAll('.shoot-node-highlight').forEach(el => el.remove());
    
    const cell = window.cellMap[cellId];
    if (!cell) return;
    
    const col = window.columnBounds[cell.colIndex];
    const row = structuredRows[cell.rowIndex];
    
    const highlight = document.createElement('div');
    highlight.className = 'shoot-node-highlight';
    highlight.style.cssText = `
        position: absolute;
        left: ${col.left}px;
        top: ${row.topLine ? row.topLine.y : 0}px;
        width: ${col.right - col.left}px;
        height: ${(row.bottomLine ? row.bottomLine.y : canvas.height) - (row.topLine ? row.topLine.y : 0)}px;
        border: 3px solid #9b59b6;
        background: rgba(155, 89, 182, 0.1);
        pointer-events: none;
        z-index: 2006;
    `;
    document.getElementById('canvasContainer').appendChild(highlight);
}

function clearShootHighlight() {
    document.querySelectorAll('.shoot-node-highlight').forEach(el => el.remove());
}

// === –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —è—á–µ–π–∫–µ ===
function showCellInfo(cellId, direction = 'self') {
    const output = document.getElementById('smartOutput');
    document.querySelectorAll('.smart-cell-highlight, .subcell-highlight, .orange-line-detector, .shoot-path, .shoot-node').forEach(el => el.remove());

    if (!window.cellMap || !window.cellMap[cellId]) {
        output.innerHTML = '<div style="color:#d9534f;">–ö–ª–µ—Ç–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞</div>';
        return;
    }

    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–π —è—á–µ–π–∫–∏
    highlightCell(cellId);
    
    // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∞ –æ—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏–π
    const hasOrangeLines = highlightOrangeLinesInCell(cellId);
    
    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å—É–±—ä—è—á–µ–µ–∫ + –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
    const subcellCount = highlightSubcells(cellId);
    
    // –°—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ –ø—Ä–æ—Å—Ç—Ä–µ–ª–∞
    const shootTree = shootRightRecursive(cellId);
    visualizeShootPath(shootTree);

    const cell = window.cellMap[cellId];
    
    let html = `<div><strong>–ê–∫—Ç–∏–≤–Ω–∞—è:</strong> ${cell.id} ‚Üí ${cell.content || '‚Äî'}</div>`;
    html += `<div style="margin-top:6px; color:#f57f17; font-weight:bold;">–°—É–±—ä—è—á–µ–µ–∫: ${subcellCount}</div>`;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏—è—Ö
    if (hasOrangeLines) {
        html += `<div style="margin-top:4px; color:#ff0000; font-weight:bold;">üîç –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—Ä–∞–Ω–∂–µ–≤—ã–µ –ª–∏–Ω–∏–∏!</div>`;
    } else {
        html += `<div style="margin-top:4px; color:#666;">–û—Ä–∞–Ω–∂–µ–≤—ã—Ö –ª–∏–Ω–∏–π –Ω–µ—Ç</div>`;
    }

    output.innerHTML = html;
    
    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –¥–µ—Ä–µ–≤–æ –ø—Ä–æ—Å—Ç—Ä–µ–ª–∞ –æ—Ç–¥–µ–ª—å–Ω–æ
    displayShootTree(shootTree);
}

// === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–¢–†–ï–õ–û–ö ===
['Up', 'Down', 'Left', 'Right'].forEach(dir => {
    document.getElementById(`smart${dir}`).addEventListener('click', () => {
        if (!currentSmartCellId) return;
        const current = window.cellMap[currentSmartCellId];
        let newRow = current.rowIndex;
        let newCol = current.colIndex;
        if (dir === 'Up') newRow--;
        else if (dir === 'Down') newRow++;
        else if (dir === 'Left') newCol--;
        else if (dir === 'Right') newCol++;

        if (newRow < 0 || newRow >= structuredRows.length) return;
        if (newCol < 0 || newCol >= window.columnBounds.length) return;

        const newId = `cell_r${newRow}_c${newCol}`;
        if (!window.cellMap[newId]) return;

        currentSmartCellId = newId;
        document.getElementById('smartCellSelect').value = newId;
        showCellInfo(newId);
    });
});
  
  </script>



  
</body>
</html>
