<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>vectorize</title>
  <style>
    body {
      margin: 30px;
      background-color: #eee;
      font-family: sans-serif;
    }
    #pdfCanvas {
      display: block;
      border: 1px solid #000;
      cursor: default;
    }
    #canvasContainer {
      position: relative;
      display: inline-block;
      overflow: auto;
    }
    #selector {
      position: absolute;
      border: 2px dashed red;
      background-color: rgba(255, 0, 0, 0.1);
      pointer-events: none;
      top: 0;
      left: 0;
    }

    .handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: red;
      border: 1px solid white;
      border-radius: 50%;
      pointer-events: auto;
      cursor: pointer;
    }
    .handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
    .handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
    .handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
    .handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

    #vectorizeBtn {
      margin-top: 15px;
      padding: 8px 16px;
      font-size: 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: none;
    }
    #vectorizeBtn:hover {
      background: #45a049;
    }

    /* Скроллбары */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    ::-webkit-scrollbar-thumb {
      background: rgb(123, 77, 214);
      border-radius: 5px;
    }
    #canvasContainer {
      scrollbar-width: thin;
      scrollbar-color: rgb(123, 77, 214) #f1f1f1;
    }
    #controls {
  margin-bottom: 15px;
}
#controls a,
#controls button {
  display: inline-block;
  vertical-align: middle;
  margin-right: 10px;
}
#vectorizeBtn {
  padding: 6px 12px;
  font-size: 14px;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: none; /* скрыта до загрузки PDF */
}
#vectorizeBtn:hover {
  background: #45a049;
}
  </style>
</head>
<body>

  <input type="file" id="pdfInput" accept=".pdf" style="display:none;">
<div id="controls">
  <a href="#" id="pdfSelect">открыть PDF</a>
  <button id="vectorizeBtn">Vectorize</button>
</div>
  <!-- <input type="file" id="pdfInput" accept=".pdf" style="display:none;">
  <div id="drop"><a href="#" id="pdfSelect">открыть PDF</a><br>или сюда</div> -->

  <div id="canvasContainer">
    <canvas id="pdfCanvas"></canvas>
    <div id="selector">
      <div class="handle nw"></div>
      <div class="handle ne"></div>
      <div class="handle sw"></div>
      <div class="handle se"></div>
    </div>
  </div>

  <!-- <button id="vectorizeBtn">Vectorize</button> -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
  <script src="potrace.js"></script>

  <script>
    let pdfDoc = null;
    const canvas = document.getElementById('pdfCanvas');
    const ctx = canvas.getContext('2d');
    const selector = document.getElementById('selector');
    const vectorizeBtn = document.getElementById('vectorizeBtn');
    let isResizing = false;
    let currentHandle = null;
    let startX, startY, startLeft, startTop, startWidth, startHeight;

    // Инициализация селектора после загрузки PDF
    function initSelector() {
      const rect = canvas.getBoundingClientRect();
      const initW = 200;
      const initH = 200;
      const left = 20;   // отступ слева
  const top = 20;    // отступ сверху

      selector.style.left = left + 'px';
      selector.style.top = top + 'px';
      selector.style.width = initW + 'px';
      selector.style.height = initH + 'px';
      selector.style.display = 'block';
      vectorizeBtn.style.display = 'inline-block';
    }

    // Обработчики ручек
    const handles = {
      nw: selector.querySelector('.handle.nw'),
      ne: selector.querySelector('.handle.ne'),
      sw: selector.querySelector('.handle.sw'),
      se: selector.querySelector('.handle.se')
    };

    function setupResize(handleName) {
      handles[handleName].addEventListener('mousedown', (e) => {
        e.stopPropagation();
        isResizing = true;
        currentHandle = handleName;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(selector.style.left) || 0;
        startTop = parseInt(selector.style.top) || 0;
        startWidth = parseInt(selector.style.width) || 0;
        startHeight = parseInt(selector.style.height) || 0;
        document.body.style.cursor = getComputedStyle(handles[handleName]).cursor;
      });
    }

    Object.keys(handles).forEach(setupResize);

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      let newLeft = startLeft;
      let newTop = startTop;
      let newWidth = startWidth;
      let newHeight = startHeight;

      switch (currentHandle) {
        case 'se':
          newWidth = Math.max(20, startWidth + dx);
          newHeight = Math.max(20, startHeight + dy);
          break;
        case 'sw':
          newWidth = Math.max(20, startWidth - dx);
          newHeight = Math.max(20, startHeight + dy);
          newLeft = startLeft + dx;
          break;
        case 'ne':
          newWidth = Math.max(20, startWidth + dx);
          newHeight = Math.max(20, startHeight - dy);
          newTop = startTop + dy;
          break;
        case 'nw':
          newWidth = Math.max(20, startWidth - dx);
          newHeight = Math.max(20, startHeight - dy);
          newLeft = startLeft + dx;
          newTop = startTop + dy;
          break;
      }

      selector.style.left = newLeft + 'px';
      selector.style.top = newTop + 'px';
      selector.style.width = newWidth + 'px';
      selector.style.height = newHeight + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        currentHandle = null;
        document.body.style.cursor = '';
      }
    });

    // Загрузка PDF
    document.getElementById('pdfSelect').addEventListener('click', (e) => {
      e.preventDefault();
      document.getElementById('pdfInput').click();
    });

    document.getElementById('pdfInput').addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (!file || !file.name.endsWith('.pdf')) return;

      const reader = new FileReader();
      reader.onload = async function() {
        const typedarray = new Uint8Array(this.result);
        // pdfDoc = await pdfjsLib.getDocument({ typedarray}).promise;
        pdfDoc = await pdfjsLib.getDocument({ data: typedarray }).promise;
        const page = await pdfDoc.getPage(1);

        const scale = 2.0;
        const viewport = page.getViewport({scale});
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        await page.render({canvasContext: ctx, viewport}).promise;
        initSelector();
      };
      reader.readAsArrayBuffer(file);
    });

    // Векторизация по кнопке
    vectorizeBtn.addEventListener('click', async () => {
      const x = parseInt(selector.style.left) || 0;
      const y = parseInt(selector.style.top) || 0;
      const width = parseInt(selector.style.width) || 0;
      const height = parseInt(selector.style.height) || 0;

      if (width < 10 || height < 10) {
        alert('Выделите область не меньше 10×10 пикселей');
        return;
      }

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

      // Ч/б
      const imageData = tempCtx.getImageData(0, 0, width, height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const gray = 0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2];
        data[i] = data[i+1] = data[i+2] = gray < 128 ? 0 : 255;
        data[i+3] = 255;
      }
      tempCtx.putImageData(imageData, 0, 0);

      // Векторизация
      tempCanvas.toBlob(function(blob) {
        const file = new File([blob], "region.png", {type: "image/png"});
        Potrace.setParameter({
          turdsize: 1,
          turnpolicy: "minority",
          optcurve: true,
          alphamax: 0.6,
          opttolerance: 0.12
        });

        Potrace.loadImageFromFile(file);
        Potrace.process(function() {
          const svgStr = Potrace.getSVG(1);
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgStr, 'image/svg+xml');
          const path = doc.querySelector('path');

          if (path) {
            const w = doc.querySelector('svg').width.baseVal.value;
            const h = doc.querySelector('svg').height.baseVal.value;
            const cleanSVG = `<svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">${path.outerHTML}</svg>`;
            navigator.clipboard.writeText(cleanSVG).then(
              () => alert(`✅ SVG скопирован! (${w}×${h})`),
              () => prompt('Скопируй:', cleanSVG)
            );
          }
        });
      });
    });
  </script>
</body>
</html>
